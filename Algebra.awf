`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Load Standard.awf
Branching Array[!Nat][T : Star](!Zr -> Empty_Array, !Next N -> Construct_Array(Head : T, Tail : Array N T))
Branching Array'[!List !Nat][T : Star](
  !Empty_List -> Empty_Array',
  !Construct_List N L -> Construct_Array' (Arrays : Array N (Array' L T)))
Struct Complex[T : Star](Real : T, Imaginary : T)
Struct Diagonal[N : !Nat, T : Star](Diagonal' : Array N T)
Struct Fraction(Num : Int, Den : Int)
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz_triangle[N : !Nat, T : Star](Toeplitz_triangle' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
Class Commutative{T : Star}<Ring>
Class Commutative_Tuple{L : !List Star}<Ring_Tuple>
Class Finite_Array{N : !Nat}<Ord_Array>(All_Array[T : Star]<Finite T> : List (Array N T))
Class Foldable{F : Arrow Star Star}(
  Fold_right[T : Star, U : Star] : Function (Function T (Function U U)) (Function U (Function (F T) U)))
Class Functor_Array{N : !Nat}(Fmap_Array[T : Star, U : Star] : Function (Function T U) (Function (Array N T) (Array N U)))
Class Mat{F : Arrow !Nat (Arrow Star Star)}(
  Adj[N : !Nat, T : Star]<Commutative T> : Function (F N T) (F N T),
  Adj_Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) (Pair (F N T) T),
  Characteristic[N : !Nat, T : Star]<Commutative T> : Function (F N T) (Array (!Next N) T),
  Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> : Function (F N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> : Function (Array N T) (Function (F N T) (Array N T)))
Class Ord_Array{N : !Nat}(Compare_Array[T : Star]<Ord T> : Function (Array N T) (Function (Array N T) Comparison))
Instance Applicative{Complex}(Apply x y = Complex (Real x (Real y)) (Imaginary x (Imaginary y)), Lift x = Complex x x)
Instance Applicative{Quaternion}(
  Apply x y = Quaternion (Qr x (Qr y)) (Qx x (Qx y)) (Qy x (Qy y)) (Qz x (Qz y)),
  Lift x = Quaternion x x x x)
Instance Commutative{Complex T}<Commutative T>
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Instance Commutative{Trivial}
Instance Commutative{Tuple L}<Commutative_Tuple L>
Instance Commutative_Tuple{!Empty_List[Star]}
Instance Commutative_Tuple{!Construct_List[Star] T L}<Commutative T, Commutative_Tuple L>
Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T = Fmap (z -> Multiply z y) (Inverse x)
Def Div_left'[F : Arrow Star Star, T : Star]<Functor F, Field T>(x : T, y : F T) : Maybe (F T) =
  Fmap (z -> Multiply_left z y) (Inverse x)
Def Div_right[T : Star]<Field T>(x : T, y : T) : Maybe T = Fmap (Multiply x) (Inverse y)
Def Div_right'[F : Arrow Star Star, T : Star]<Functor F, Field T>(x : F T, y : T) : Maybe (F T) =
  Fmap (Multiply_right x) (Inverse y)
Instance Finite{Array N T}<Finite T, Finite_Array N>(All = All_Array)
Instance Finite_Array{!Zr}(All_Array = Lift Empty_Array)
Instance Finite_Array{!Next N}<Finite_Array N>(All_Array = Zip Construct_Array All All)
Instance Foldable{Complex}(Fold_right f x y = f (Real y) (f (Imaginary y) x))
Instance Foldable{Either T}(Fold_right f x y = Match y {Left _ -> x, Right z -> f z x})
Instance Foldable{List}(Fold_right f x y = Match y {Empty_List -> x, Construct_List z a -> f z (Fold_right f x a)})
Instance Foldable{Maybe}(Fold_right f x y = Match y {Nothing -> x, Wrap z -> f z x})
Instance Foldable{Quaternion}(Fold_right f x y = f (Qr y) (f (Qx y) (f (Qy y) (f (Qz y) x))))
Instance Functor{Array N}<Functor_Array N>(Fmap = Fmap_Array)
Instance Functor{Complex}(Fmap f x = Complex (f (Real x)) (f (Imaginary x)))
Instance Functor{Quaternion}(Fmap f x = Quaternion (f (Qr x)) (f (Qx x)) (f (Qy x)) (f (Qz x)))
Instance Functor_Array{!Zr}(Fmap_Array _ _ = Empty_Array)
Instance Functor_Array{!Next N}<Functor_Array N>(Fmap_Array f a = Construct_Array (f (Head a)) (Fmap f (Tail a)))
Def Identity[T : Star]<Ring T> : T = Convert 1
Def Minus[T : Star]<Ring T>(x : T, y : T) : T = Add x (Negate y)
Instance Ord{Array N T}<Ord T, Ord_Array N>(Compare = Compare_Array)
Instance Ord{Quaternion T}<Ord T>(
  Compare x y =
    Compare
      (Construct_Tuple (Qr x) (Construct_Tuple (Qx x) (Construct_Tuple (Qy x) (Construct_Tuple (Qz x) Empty_Tuple))))
      (Construct_Tuple (Qr y) (Construct_Tuple (Qx y) (Construct_Tuple (Qy y) (Construct_Tuple (Qz y) Empty_Tuple)))))
Instance Ord_Array{!Zr}(Compare_Array _ _ = EQ)
Instance Ord_Array{!Next N}<Ord_Array N>(
  Compare_Array x y =
    Compare
      (Construct_Tuple (Head x) (Construct_Tuple (Tail x) Empty_Tuple))
      (Construct_Tuple (Head y) (Construct_Tuple (Tail y) Empty_Tuple)))
Instance Field{Quaternion T}<Commutative T, Field T>(
  Inverse x = Div_right' (Quaternion (Qr x) (Negate (Qx x)) (Negate (Qy x)) (Negate (Qz x))) (Sum_squares x))
Def Multiply_left[T : Star, F : Arrow Star Star]<Functor F, Ring T>(x : T, y : F T) : F T = Fmap (Multiply x) y
Def Multiply_right[F : Arrow Star Star, T : Star]<Functor F, Ring T>(x : F T, y : T) : F T = Fmap (z -> Multiply z y) x
Def Pow[T : Star]<Field T>(x : T, i : Int) : Maybe T =
  Match Less i 0 {False -> Wrap (Pow' x i), True -> Inverse (Pow' x (Negate i))}
Def Pow'[T : Star]<Ring T>(x : T, i : Int) : T =
  Match i {
    0 -> Identity,
    Default -> (z -> (Match Rem' i 2 {0 -> Id, 1 -> Multiply x, Default -> Crash}) (Multiply z z)) (Pow' x (Div' y 2))}
Instance Ring{Complex T}<Ring T>(
  Add = Add',
  Convert x = Complex (Convert x) Zero,
  Multiply x y =
    Complex
      (Minus (Multiply (Real x) (Real y)) (Multiply (Imaginary x) (Imaginary y)))
      (Add (Multiply (Real x) (Imaginary y)) (Multiply (Imaginary x) (Real y))),
  Negate = Negate')
Instance Ring{Quaternion T}<Ring T>(
  Add = Add',
  Convert x = Quaternion (Convert x) Zero Zero Zero,
  Multiply x y =
    Quaternion
      (Minus
        (Minus (Minus (Multiply (Qr x) (Qr y)) (Multiply (Qx x) (Qx y))) (Multiply (Qy x) (Qy y)))
        (Multiply (Qz x) (Qz y)))
      (Add
        (Minus (Add (Multiply (Qr x) (Qx y)) (Multiply (Qx x) (Qr y))) (Multiply (Qy x) (Qz y)))
        (Multiply (Qz x) (Qy y)))
      (Minus
        (Add (Add (Multiply (Qr x) (Qy y)) (Multiply (Qx x) (Qz y))) (Multiply (Qy x) (Qr y)))
        (Multiply (Qz x) (Qx y)))
      (Add
        (Add (Minus (Multiply (Qr x) (Qz y)) (Multiply (Qx x) (Qy y))) (Multiply (Qy x) (Qx y)))
        (Multiply (Qz x) (Qr y))),
  Negate = Negate')
Def Sum[F : Arrow Star Star, T : Star]<Foldable F, Ring T> : Function (F T) T = Fold_right Add Zero
Def Sum_squares[F : Arrow Star Star, T : Star]<Foldable F, Functor F, Ring T>(x : F T) : T = Sum (Fmap (y -> Pow' y 2) x)
Def Zero[T : Star]<Ring T> : T = Convert 0
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````