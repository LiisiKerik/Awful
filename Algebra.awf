````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Load (Standard.awf)
Branching Array[T : Star]{Zero -> Empty_Array, Next N -> Construct_Array(Head : T, Tail : Array N T)}
Struct Complex[T : Star](Real : T, Imaginary : T)
~/
Struct Fraction(Num : Int, Den : Int) =
  Let
    Pair Sign_Num Num' = Separate Num, Pair Sign_Den Den' = Separate Den, GCD_Num_Den = GCD Num_0 Den_0, 
  In
    Fraction () (Div' GCD_Num_Den}
/~
Hidden Struct Fraction(Num : Int, Den : Int)
Hidden Struct Polynomial[T : Star](Coefficients : List T)
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[T : Star]{
  Zero -> Empty_Square,
  Next N -> Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T)}
Struct Toeplitz[N : Nat, T : Star](Toeplitz' : Array N T)
Branching Triangle[T : Star]{
  Zero -> Empty_Triangle,
  Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T)}
Class Commutative{_ : Star}<Ring>
Class Mat{F : Nat -> Star -> Star}(
  Adj[N : Nat, T : Star]<Commutative T> : F N T -> F N T,
  Adj_Det[N : Nat, T : Star]<Commutative T> : F N T -> F N T * T,
  Characteristic[N : Nat, T : Star]<Commutative T> : F N T -> Array (Next N) T,
  Det[N : Nat, T : Star]<Commutative T> : F N T -> T,
  Matrix_by_vector[N : Nat, T : Star]<Ring T> : F N T -> Array N T -> Array N T,
  Vector_by_matrix[N : Nat, T : Star]<Ring T> : Array N T -> F N T -> Array N T)
Operator !+ Add' 1 Left
Def Add'[F : Star -> Star, T : Star]<Applicative F, Ring T> : F T -> F T -> F T = Zip Add
Instance Applicative{Complex}(Compose (Complex f g) (Complex x y) = Complex (f x) (g y), Lift x = Complex x x)
Instance Applicative{Quaternion}(
  Compose (Quaternion f g h i) (Quaternion x y z a) = Quaternion (f x) (g y) (h z) (i a),
  Lift x = Quaternion x x x x)
Def Array_to_List[N : Nat, T : Star] : Array N T -> List T =
  Branch N {Zero -> Empty_Array -> Empty_List, Next _ -> Construct_Array x y -> x : Array_to_List y}
Instance Commutative{Complex T}<Commutative T>
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Def Div_left'[F : Star -> Star, T : Star]<Functor F, Field T>(x : T, y : F T) : Maybe (F T) =
  (z -> Multiply_left z y) . Inverse x
Def Div_right'[F : Star -> Star, T : Star]<Functor F, Field T>(x : F T, y : T) : Maybe (F T) = Multiply_right x . Inverse y
Instance Field{Complex T}<Commutative T, Field T>(
  Inverse (Complex x y) = Div_right' (Complex x (Negate y)) (Sum_squares (!List ![x, y])))
Instance Field{Quaternion T}<Commutative T, Field T>(
  Inverse (Quaternion x y z a) =
    Div_right' (Quaternion x (Negate y) (Negate z) (Negate a)) (Sum_squares (!List ![x, y, z, a])))
Instance Finite{Array N T}<Finite T>(All = Branch N {Zero -> Lift Empty_Array, Next _ -> Zip Construct_Array All All})
Instance Functor{Array N}(
  Apply f = Branch N {Zero -> Empty_Array -> Empty_Array, Next _ -> Construct_Array x y -> Construct_Array (f x) (Compose f y)})
Instance Functor{Complex}(Apply f (Complex x y) = Complex (f x) (f y))
Instance Functor{Quaternion}(Apply f (Quaternion x y z a) = Quaternion (f x) (f y) (f z) (f a))
Def GCD(x : Int, y : Int) : Int = Crash
Def Multiply_left[T : Star, F : Star -> Star]<Functor F, Ring T>(x : T, y : F T) : F T = Multiply x . y
Def Multiply_right[F : Star -> Star, T : Star]<Functor F, Ring T>(x : F T, y : T) : F T = (z -> z * y) . x
Instance Ord{Array N T}<Ord T>(
  Compare =
    Branch N {
      Zero -> Empty_Array -> Empty_Array -> EQ,
      Next _ -> Construct_Array x y -> Construct_Array z a -> Compare (Pair x y) (Pair z a)})
Instance Ord{Complex T}<Ord T>(Compare (Complex x y) (Complex z a) = Compare (Pair x y) (Pair z a))
Instance Ord{Quaternion T}<Ord T>(
  Compare (Quaternion x y z a) (Quaternion b c d e) = Compare (Pair x (Pair y (Pair z a))) (Pair b (Pair c (Pair d e))))
Instance Ring{Complex T}<Ring T>(
  Add = Add',
  Convert x = Complex (Convert x) Zr,
  Multiply (Complex x y) (Complex z a) = Complex (Minus (x * z) (y * a)) (x * a + y * z),
  Negate = Negate')
Instance Ring{Quaternion T}<Ring T>(
  Add = Add',
  Convert x = Quaternion (Convert x) Zr Zr Zr,
  Multiply (Quaternion x y z a) (Quaternion b c d e) =
    Quaternion
      (Minus (Minus (Minus (x * b) (y * c)) (z * d)) (a * e))
      (Minus (x * c + y * b) (z * e) + a * d)
      (Minus (x * d + y * e + z * b) (a * c))
      (Minus (x * e) (y * d) + z * c + a * b),
  Negate = Negate')
Def Separate(x : Int) : Int * Int = Match Compare x 0 {LT -> Pair -1 (Negate x), EQ -> Pair 0 0, GT -> Pair 1 x}
Def Sqr[T : Star]<Ring T>(x : T) : T = x * x
Def Sum[F : Star -> Star, T : Star]<Foldable F, Ring T> : F T -> T = Fold_right Add Zr
Def Sum_squares[F : Star -> Star, T : Star]<Foldable F, Functor F, Ring T>(x : F T) : T = Sum (Sqr . x)
`Instance Writeable{Array N T}<Writeable T, Writeable_Array N>(Write_Brackets = Write_Brackets_Array)
Instance Writeable{Array N T}<Writeable T>(
  Write_Brackets x = Branch N {
    Zero -> !List !["E", "m", "p", "t", "y", "_", "A", "r", "r", "a", "y"] & 0,
    Next _ ->
      Construct_Array y z ->
        Cat
          (!List !["!", "A", "r", "r", "a", "y", " ", "!", "["])
          (Cat (Interleave (!List ![",", " "]) (Write . Array_to_List x)) (Lift "]")) &
        1})
Instance Writeable{Complex T}<Writeable T>(
  Write_Brackets (Complex x y) = !List !["C", "o", "m", "p", "l", "e", "x"] ... x ... y & 1)
Instance Writeable{Fraction}(Write_Brackets (Fraction x y) = !List !["F", "r", "a", "c", "t", "i", "o", "n"] ... x ... y & 1)
Instance Writeable{Quaternion T}<Writeable T>(
  Write_Brackets (Quaternion x y z a) = !List !["Q", "u", "a", "t", "e", "r", "n", "i", "o", "n"] ... x ... y ... z ... a ... 1)
Instance Writeable{Square N T}<Writeable T>(
  Write_Brackets x =
    Branch N {Zero -> !List !["E", "m", "p", "t", "y", "_", "S", "q", "u", "a", "r", "e"] & 0, Next _ -> Crash})
Instance Writeable{Toeplitz N T}<Writeable T>(Write_Brackets (Toeplitz x) =
  Cat
    (!List !["!", "T", "o", "e", "p", "l", "i", "t", "z", " ", "!", "["])
    (Cat (Interleave (!List ![",", " "]) (Write . Array_to_List x)) (Lift "]")) &
  1)
Instance Writeable{Triangle N T}<Writeable T>(
  Write_Brackets x =
    Branch N {Zero -> !List !["E", "m", "p", "t", "y", "_", "T", "r", "i", "a", "n", "g", "l", "e"] & 0, Next _ -> Crash})
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````