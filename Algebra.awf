`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Branching Array[!Nat][T : Star](!Next N -> Construct_Array(Head : T, Tail : Array N T), !Zr -> Empty_Array)
Struct Complex[T : Star](Real : T, Imaginary : T)
Algebraic Either[T : Star, U : Star](Left T, Right U)
Struct Fraction[T : Star](Numerator : T, Denominator : T)
Algebraic List[T : Star](Construct_List T (List T), Empty_List)
Algebraic Logical(False, True)
Struct Pair[T : Star, U : Star](First : T, Second : U)
Struct Polynomial[T : Star](Coefficients : List T)
Struct Quaternion[T : Star](Qa : T, Qx : T, Qy : T, Qz : T)
Struct Trivial
Class Commutative{T : Star}<Ring>
Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Finite{T : Star}(All : List T)
Class Functor{F : Arrow Star Star}(Map[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))
Class Ordered{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Writeable{T : Star}(Write : Function T (List Char))
`Abstract Apply{F : Arrow Star Star}[T : Star, U : Star] : F (T -> U) -> F T -> F U
`Abstract Det{F : Arrow Star Star}[T : Star] : F T -> T
`Abstract Fold{F : Arrow Star Star}[T : Star, U : Star] : (T -> U -> U) -> U -> F T -> U
`Abstract Top_row{F : # -> * -> *}[N : #, T : Star] : F N T -> Array (N - 1) T
`Instance Add{Array _ T}<Add T> = Map Apply (Map Add)
`Instance Add{Pair T U}<Add T, Add U> = Zip_Pair Add Add
Def Add_Pair[T : Star, U : Star] :
  Function
    (Function T (Function T T))
    (Function (Function U (Function U U)) (Function (Pair T U) (Function (Pair T U) (Pair T U)))) =
      Zip_Pair
~/
Instance Apply{Array _} x y = Array (Apply (Array_function x) (Array_function y))
Def Apply_Array[N : #, T : Star, U : Star](x : Array N (T -> U), y : Array N T) : Array N U =
  Array (Apply_Function (Array_function x) (Array_function y))
Def Apply_Array[A : Star, B : Star](x : Array (Function A B), y : Array A) : Maybe (Array B) =
  Match Equal_Int (Length x) (Length y) {
    False -> Nothing,
    True -> Array (Length x) (z -> (Unsafe_Index x z) (Unsafe_Index y z))}
/~
`Instance Apply{Complex} x y = Complex (Real x (Real y)) (Imaginary x (Imaginary y))
Def Apply_Complex[T : Star, U : Star](x : Complex (Function T U), y : Complex T) : Complex U =
  Complex (Real x (Real y)) (Imaginary x (Imaginary y))
Def Apply_Either[A : Star, B : Star, C : Star](x : Either A (Function B C), y : Either A B) : Either A C = Match x {
  Left z -> Left z,
  Right f -> Map f y}
`Instance Apply{Function _} f g x = f x (g x)
Def Apply_Function[A : Star, B : Star, C : Star](f : Function A (Function B C), g : Function A B, x : A) : C = f x (g x)
Def Apply_List[T : Star, U : Star](x : List (Function T U), y : List T) : List U = Match x {
  Construct_List f z -> Join_List (Map f y) (Apply_List z y),
  Empty_List -> Empty_List}
Def Apply_Maybe[A : Star, B : Star](x : Maybe (Function A B), y : Maybe A) : Maybe B = Match x {
  Nothing -> Nothing,
  Wrap f -> Map f y}
Def Bimap[T : Star, U : Star, V : Star, W : Star](f : Function T U, g : Function V W, x : Pair T V) : Pair U W =
  Pair (f (First x)) (g (Second x))
Def Clean[T : Star](Equal_T : Function T (Function T Logical), x : List T) : List T = Match x {
  Construct_List y z -> (w -> (a -> Match Equal_T y Crash {
    False -> a,
    True -> Match w {
      Construct_List -> a,
      Empty_List -> Empty_List}}) (Construct_List y w)) (Clean Equal_T z),
  Empty_List -> Empty_List}
Instance Commutative{Complex T}<Commutative T>
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Instance Commutative{Polynomial T}<Commutative T>
Instance Commutative{Trivial}
Def Convert_Polynomial[T : Star]
  (Convert_T : Function Int T, Equal_T : Function T (Function T Logical), x : Int) : Polynomial T =
    Polynomial (Clean Equal_T (Lift_List (Convert_T x)))
Def Det_Complex[T : Star](Add_T : Function T (Function T T), Multiply_T : Function T (Function T T), x : Complex T) : T =
  Add_T (Crash (Real x)) (Crash (Imaginary x))
Def Equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> True, Default -> False}
Instance Field{Complex T}<Commutative T>(Inverse x = Crash)
Instance Field{Int}(Inverse x = Match x {-1 -> Wrap -1, 1 -> Wrap 1, Default -> Nothing})
Instance Field{Logical}(Inverse x = Match x {False -> Nothing, True -> Wrap x})
Instance Field{Pair T U}<Field T, Field U>(
  Inverse x =
    Match Inverse (First x) {
      Nothing -> Nothing,
      Wrap y -> Match Inverse (Second x) {Nothing -> Nothing, Wrap z -> Wrap (Pair y z)}})
Instance Field{Trivial}(Inverse _ = Wrap Trivial)
Def Filter_List[T : Star](f : Function T Logical, x : List T) : List T = Match x {
  Construct_List y z -> (w -> Match f y {
    False -> w,
    True -> Construct_List y w}) (Filter_List f z),
  Empty_List -> Empty_List}
Def Filter_Maybe[T : Star](f : Function T Logical, x : Maybe T) : Maybe T = Match x {
  Nothing -> Nothing,
  Wrap y -> Match f y {
    False -> Nothing,
    True -> x}}
Instance Functor{Array N}(Map f x = !Match N {!Next -> Construct_Array (f (Head x)) (Map f (Tail x)), !Zr -> Empty_Array})
Instance Functor{Complex}(Map f x = Complex (f (Real x)) (f (Imaginary x)))
Instance Functor{Either _}(Map f x = Match x {Left y -> Left y, Right y -> Right (f y)})
Instance Functor{Function _}(Map f g x = f (g x))
Instance Functor{List}(Map f x = Match x {Empty_List -> Empty_List, Construct_List y z -> Construct_List (f y) (Map f z)})
Instance Functor{Maybe}(Map f x = Match x {Nothing -> Nothing, Wrap y -> Wrap (f y)})
Instance Functor{Pair _}(Map f x = Pair (First x) (f (Second x)))
Instance Functor{Polynomial}(Map f p = Polynomial (Map f (Coefficients p)))
Instance Finite{Comparison}(All = Construct_List LT (Construct_List EQ (Construct_List GT Empty_List)))
`Def All_Complex[T : Star](All_T : List T) : List (Complex T) = Zip Apply_List Apply_List Lift_List Complex All_T All_T
~/
Def All_Either[T : Star, U : Star](All_T : List T, All_U : List U) : List (Either T U) =
  Join_List (Map Left All_T) (Map Right All_U)
/~
`Def All_Function[T : Star, U : Star](All_T : List T, All_U : List U) : List (Function T U) = Crash
Instance Finite{Logical}(All = Construct_List False (Construct_List True Empty_List))
`Instance All{Pair T U}<All T, All U> = Zip Pair All All
~/
Def All_Pair[T : Star, U : Star](All_T : List T, All_U : List U) : List (Pair T U) =
  Zip Apply_List Apply_List Lift_List Pair All_T All_U
/~
Instance Finite{Trivial}(All = Construct_List Trivial Empty_List)
Def Flatten_Either[T : Star, U : Star](x : Either T (Either T U)) : Either T U = Match x {
  Left y -> Left y,
  Right y -> y}
Def Flatten_Function[T : Star, U : Star](f : Function T (Function T U), x : T) : U = f x x
Def Flatten_List[T : Star](x : List (List T)) : List T = Match x {
  Construct_List y z -> Join_List y (Flatten_List z),
  Empty_List -> Empty_List}
Def Flatten_Maybe[T : Star](x : Maybe (Maybe T)) : Maybe T = Match x {
  Nothing -> Nothing,
  Wrap y -> y}
Def Flip[A : Star, B : Star, C : Star](f : Function A (Function B C), x : B, y : A) : C = f y x
`Instance Fold{Complex} f x y = Crash
Def Fold_Left[T : Star, U : Star](f : Function T (Function U T), x : T, y : List U) : T = Match y {
  Construct_List z w -> Fold_Left f (f x z) w,
  Empty_List -> x}
Def Fold_Right[T : Star, U : Star](f : Function T (Function U U), x : U, y : List T) : U = Match y {
  Construct_List z w -> f z (Fold_Right f x y),
  Empty_List -> x}
Def Greater[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {GT -> True, Default -> False}
Def Greater_or_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {LT -> False, Default -> True}
Def Id[A : Star](x : A) : A = x
Def Identity[T : Star]<Ring T> : T = Convert 0
~/
Def Join_Array[A : Star](x : Array A, y : Array A) : Array A =
  Unsafe_Array (Add_Int (Length x) (Length y)) (z -> Match Less_Int z (Length x) {
    False -> Unsafe_Index y (Minus Add_Int Negate_Int z (Length x)),
    True -> Unsafe_Index x z})
/~
Def Join_List[T : Star](x : List T, y : List T) : List T = Match x {
  Construct_List z w -> Construct_List z (Join_List w y),
  Empty_List -> y}
~/
Def Lead_Complex[T : Star] : Function (Complex T) T = Real
Def Lead_Quaternion[T : Star] : Function (Quaternion T) T = Qx
/~
Def Left_division[T : Star]<Field T>(x : T, y : T) : Maybe T = Map (z -> Multiply z x) (Inverse y)
Def Less[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {LT -> True, Default -> False}
Def Less_or_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {GT -> False, Default -> True}
~/
Instance Lift{Array _} = Map Array Lift
Def Lift_Array[N : #, T : Star] : T -> Array N T = Map Array Lift_Function
Def Lift_Array[A : Star](x : Int, y : A) : Maybe (Array A) = Array x (Lift_Function y)
/~
`Instance Lift{Complex} x = Complex x x
Def Lift_Complex[T : Star](x : T) : Complex T = Complex x x
`Instance Lift{Either _} = Right
Def Lift_Either[A : Star, B : Star] : Function B (Either A B) = Right
`Instance Lift{Function _} x _ = x
Def Lift_Function[A : Star, B : Star](x : A, _ : B) : A = x
Def Lift_List[T : Star](x : T) : List T = Construct_List x Empty_List
`Instance Lift{Maybe} = Wrap
Def Lift_Maybe[T : Star] : Function T (Maybe T) = Wrap
~/
Instance Map{Array _} x y = Array (Map x (Array_function y))
Def Map_Array[T : Star, U : Star, N : #](x : T -> U, y : Array N T) : Array N U = Array (Map x (Array_function y))
Def Map_Array[A : Star, B : Star](f : Function A B, x : Array A) : Array B =
  Unsafe_Array (Length x) (y -> f (Unsafe_Index x y))
/~
Def Minus[T : Star]<Ring T>(x : T, y : T) : T = Add x (Negate y)
Def Not(x : Logical) : Logical = Match x {
  False -> True,
  True -> False}
Def Not_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> False, Default -> True}
Instance Ordered{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, Default -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, Default -> GT}})
Instance Ordered{Complex T}<Ordered T>(
  Compare x y = Match Compare (Real x) (Real y) {LT -> LT, EQ -> Compare (Imaginary x) (Imaginary y), GT -> GT})
Instance Ordered{Either T U}<Ordered T, Ordered U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right -> LT},
      Right z -> Match y {Left -> GT, Right w -> Compare z w}})
Instance Ordered{Function T U}<Finite T, Ordered U>(Compare f g = Compare (Map f All) (Map g All))
Instance Ordered{Int}(Compare = Compare_Int)
Instance Ordered{List T}<Ordered T>(
  Compare x y =
    Match x {
      Construct_List z w ->
        Match y {Construct_List a b -> (c -> Match c {EQ -> Compare w b, Default -> c}) (Compare z a), Empty_List -> GT},
      Empty_List -> Match y {Construct_List -> LT, Empty_List -> EQ}})
Instance Ordered{Logical}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Instance Ordered{Maybe T}<Ordered T>(
  Compare x y =
    Match x {Nothing -> Match y {Nothing -> EQ, Wrap -> LT}, Wrap z -> Match y {Nothing -> GT, Wrap w -> Compare z w}})
Instance Ordered{Pair T U}<Ordered T, Ordered U>(
  Compare x y = Match Compare (First x) (First y) {LT -> LT, EQ -> Compare (Second x) (Second y), GT -> GT})
Instance Ordered{Trivial}(Compare _ _ = EQ)
Def Right_division[T : Star]<Field T>(x : T, y : T) : Maybe T = Map (Multiply x) (Inverse y)
Instance Ring{Complex T}<Ring T>(
  Add x y = Complex (Add (Real x) (Real y)) (Add (Imaginary x) (Imaginary y)),
  Convert x = Complex (Convert x) Zero,
  Multiply x y =
    Complex
      (Minus Add Negate (Multiply (Real x) (Real y)) (Multiply (Imaginary x) (Imaginary y)))
      (Add (Multiply (Real x) (Imaginary y)) (Multiply (Imaginary x) (Real y))),
  Negate x = Complex (Negate (Real x)) (Negate (Imaginary x)))
Instance Ring{Int}(
  Add = Add_Int,
  Convert = Id,
  Multiply = Multiply_Int,
  Negate = Negate_Int)
Instance Ring{Logical}(
  Add = Not_equal,
  Convert x = Equal (Mod_Int x 2) 1,
  Multiply x y = Match x {False -> False, True -> y},
  Negate = Id)
Instance Ring{Pair T U}<Ring T, Ring U>(
  Add x y = Pair (Add (First x) (First y)) (Add (Second x) (Second y)),
  Convert x = Pair (Convert x) (Convert x),
  Multiply x y = Pair (Multiply (First x) (First y)) (Multiply (Second x) (Second y)),
  Negate x = Pair (Negate (First x)) (Negate (Second x)))
Instance Ring{Trivial}(Add _ _ = Trivial, Convert _ = Trivial, Multiply _ _ = Trivial, Negate _ = Trivial)
Def Sum[T : Star, F : Arrow Star Star]
  (
    Add_T : Function T (Function T T),
    Convert_T : Function Int T,
    f : Function (Function T (Function T T)) (Function T (Function (F T) T))) :
      Function (F T) T =
        f Add_T (Zero Convert_T)
Instance Writeable{Complex T}<Writeable T>(Write x = Crash)
Instance Writeable{Logical}(
  Write x =
    Match x {
      False ->
        Construct_List "F" (Construct_List "a" (Construct_List "l" (Construct_List "s" (Construct_List "e" Empty_List)))),
      True -> Construct_List "T" (Construct_List "r" (Construct_List "u" (Construct_List "e" Empty_List)))})
Instance Writeable{Trivial}(
  Write _ =
    Construct_List
      "T"
      (Construct_List
        "r"
        (Construct_List "i" (Construct_List "v" (Construct_List "i" (Construct_List "a" (Construct_List "l" Empty_List)))))))
Def Zero[T : Star]<Ring T> : T = Convert 0
~/
Def Zip[F : Arrow Star Star, T : Star, U : Star, V : Star](
  Apply_F' : Function (F (Function T (Function U V))) (Function (F T) (F (Function U V))),
  Apply_F'' : Function (F (Function U V)) (Function (F U) (F V)),
  Lift_F : Function (Function T (Function U V)) (F (Function T (Function U V))),
  f : Function T (Function U V),
  x : F T) : Function (F U) (F V) =
    Apply_F'' (Map_Functor Apply_F' Lift_F f x)
/~
Def Zip_Pair
  [A : Star, B : Star, C : Star, D : Star, E : Star, F : Star]
  (f : Function A (Function B C), g : Function D (Function E F), x : Pair A D, y : Pair B E) :
  Pair C F =
    Pair (f (First x) (First y)) (g (Second x) (Second y))
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````