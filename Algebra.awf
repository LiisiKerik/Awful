Load Either.awf
Load Finite.awf
Load Logical.awf
Load List.awf
Load Ord.awf
Load Pair.awf
Load Ring.awf
Load Standard.awf
Branching Array[T : Type](Zr -> Empty_Array, Next N -> Construct_Array(Head : T, Tail : Array N T))
Named_struct Fraction(Num : Int, Den : Int)
Branching Square[T : Type](
  Zr -> Empty_Square,
  Next N -> Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Named_struct Toeplitz[N : Nat, T : Type](Toeplitz' : Array N T)
Branching Triangle[T : Type](
  Zr -> Empty_Triangle,
  Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
Class Finite_Array{N : Nat}<Ord_Array>(All_Array[T : Type]<Finite T> : List (Array N T))
Class Foldable{F : Type -> Type}(Fold_right[T : Type, U : Type] : (T -> U -> U) -> U -> F T -> U)
Class Functor_Array{N : Nat}(Fmap_Array[T : Type, U : Type] : (T -> U) -> Array N T -> Array N U)
Class Mat{F : Nat -> Type -> Type}(
  Adj[N : Nat, T : Type]<Commutative T> : F N T -> F N T,
  Adj_Det[N : Nat, T : Type]<Commutative T> : F N T -> Pair (F N T) T,
  Characteristic[N : Nat, T : Type]<Commutative T> : F N T -> Array (Next N) T,
  Det[N : Nat, T : Type]<Commutative T> : F N T -> T,
  Matrix_by_vector[N : Nat, T : Type]<Ring T> : F N T -> Array N T -> Array N T,
  Vector_by_matrix[N : Nat, T : Type]<Ring T> : Array N T -> F N T -> Array N T)
Class Ord_Array{N : Nat}(Compare_Array[T : Type]<Ord T> : Array N T -> Array N T -> Comparison)
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Instance Finite{Array N T}<Finite T, Finite_Array N>(All = All_Array)
Instance Finite_Array{Zr}(All_Array = Return Empty_Array)
Instance Finite_Array{Next N}<Finite_Array N>(All_Array = Zip Construct_Array All All)
Instance Foldable{Either T}(Fold_right f x y = Match y {Left _ -> x, Right z -> f z x})
Instance Foldable{List}(Fold_right f x y = Match y {Empty_List -> x, Construct_List z a -> f z (Fold_right f x a)})
Instance Foldable{Maybe}(Fold_right f x y = Match y {Nothing -> x, Wrap z -> f z x})
Instance Functor{Array N}<Functor_Array N>(Fmap = Fmap_Array)
Instance Functor_Array{Zr}(Fmap_Array _ _ = Empty_Array)
Instance Functor_Array{Next N}<Functor_Array N>(Fmap_Array f a = Construct_Array (f (Head a)) (Fmap f (Tail a)))
Def Multiply_left[T : Type, F : Type -> Type]<Functor F, Ring T>(x : T, y : F T) : F T = Fmap (Multiply x) y
Def Multiply_right[F : Type -> Type, T : Type]<Functor F, Ring T>(x : F T, y : T) : F T = Fmap (z -> z * y) x
Instance Ord{Array N T}<Ord T, Ord_Array N>(Compare = Compare_Array)
Instance Ord_Array{Zr}(Compare_Array _ _ = EQ)
Instance Ord_Array{Next N}<Ord_Array N>(Compare_Array x y = Compare (Pair (Head x) (Tail x)) (Pair (Head y) (Tail y)))
Def Sum[F : Type -> Type, T : Type]<Foldable F, Ring T> : F T -> T = Fold_right Add Zero