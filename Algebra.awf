`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Load Standard.awf
Branching Array[!Nat][T : Star](!Zr -> Empty_Array, !Next N -> Construct_Array(Head : T, Tail : Array N T))
Struct Complex[T : Star](Real : T, Imaginary : T)
Struct Fraction(Num : Int, Den : Int)
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz[N : !Nat, T : Star](Toeplitz' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
Struct Trivial
Class Commutative{_ : Star}<Ring>
Class Finite_Array{N : !Nat}<Ord_Array>(All_Array[T : Star]<Finite T> : List (Array N T))
Class Foldable{F : Arrow Star Star}(
  Fold_right[T : Star, U : Star] : Function (Function T (Function U U)) (Function U (Function (F T) U)))
Class Functor_Array{N : !Nat}(Fmap_Array[T : Star, U : Star] : Function (Function T U) (Function (Array N T) (Array N U)))
Class Mat{F : Arrow !Nat (Arrow Star Star)}(
  Adj[N : !Nat, T : Star]<Commutative T> : Function (F N T) (F N T),
  Adj_Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) (Pair (F N T) T),
  Characteristic[N : !Nat, T : Star]<Commutative T> : Function (F N T) (Array (!Next N) T),
  Det[N : !Nat, T : Star]<Commutative T> : Function (F N T) T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> : Function (F N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> : Function (Array N T) (Function (F N T) (Array N T)))
Class Ord_Array{N : !Nat}(Compare_Array[T : Star]<Ord T> : Function (Array N T) (Function (Array N T) Comparison))
Class Writeable_Array{N : !Nat}(
  Write_Brackets_Array[T : Star]<Writeable T> : Function (Array N T) (Pair (List Char) Logical))
Class Writeable_Square{N : !Nat}(
  Write_Brackets_Square[T : Star]<Writeable T> : Function (Square N T) (Pair (List Char) Logical))
Class Writeable_Triangle{N : !Nat}(
  Write_Brackets_Triangle[T : Star]<Writeable T> : Function (Triangle N T) (Pair (List Char) Logical))
Instance Applicative{Complex}(Apply x y = Complex (Real x (Real y)) (Imaginary x (Imaginary y)), Lift x = Complex x x)
Instance Applicative{Quaternion}(
  Apply x y = Quaternion (Qr x (Qr y)) (Qx x (Qx y)) (Qy x (Qy y)) (Qz x (Qz y)),
  Lift x = Quaternion x x x x)
Instance Commutative{Complex T}<Commutative T>
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Instance Commutative{Trivial}
Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T = Fmap (z -> Multiply z y) (Inverse x)
Def Div_left'[F : Arrow Star Star, T : Star]<Functor F, Field T>(x : T, y : F T) : Maybe (F T) =
  Fmap (z -> Multiply_left z y) (Inverse x)
Def Div_right[T : Star]<Field T>(x : T, y : T) : Maybe T = Fmap (Multiply x) (Inverse y)
Def Div_right'[F : Arrow Star Star, T : Star]<Functor F, Field T>(x : F T, y : T) : Maybe (F T) =
  Fmap (Multiply_right x) (Inverse y)
Instance Field{Complex T}<Commutative T, Field T>(
  Inverse x = Div_right' (Complex (Real x) (Negate (Imaginary x))) (Sum_squares x))
Instance Field{Quaternion T}<Commutative T, Field T>(
  Inverse x = Div_right' (Quaternion (Qr x) (Negate (Qx x)) (Negate (Qy x)) (Negate (Qz x))) (Sum_squares x))
Instance Field{Trivial}(Inverse = Wrap)
Instance Finite{Array N T}<Finite T, Finite_Array N>(All = All_Array)
Instance Finite{Trivial}(All = Lift Trivial)
Instance Finite_Array{!Zr}(All_Array = Lift Empty_Array)
Instance Finite_Array{!Next N}<Finite_Array N>(All_Array = Zip Construct_Array All All)
Instance Foldable{Complex}(Fold_right f x y = f (Real y) (f (Imaginary y) x))
Instance Foldable{Either T}(Fold_right f x y = Match y {Left _ -> x, Right z -> f z x})
Instance Foldable{List}(Fold_right f x y = Match y {Empty_List -> x, Construct_List z a -> f z (Fold_right f x a)})
Instance Foldable{Maybe}(Fold_right f x y = Match y {Nothing -> x, Wrap z -> f z x})
Instance Foldable{Quaternion}(Fold_right f x y = f (Qr y) (f (Qx y) (f (Qy y) (f (Qz y) x))))
Instance Functor{Array N}<Functor_Array N>(Fmap = Fmap_Array)
Instance Functor{Complex}(Fmap f x = Complex (f (Real x)) (f (Imaginary x)))
Instance Functor{Quaternion}(Fmap f x = Quaternion (f (Qr x)) (f (Qx x)) (f (Qy x)) (f (Qz x)))
Instance Functor_Array{!Zr}(Fmap_Array _ _ = Empty_Array)
Instance Functor_Array{!Next N}<Functor_Array N>(Fmap_Array f a = Construct_Array (f (Head a)) (Fmap f (Tail a)))
Def Identity[T : Star]<Ring T> : T = Convert 1
Def Minus[T : Star]<Ring T>(x : T, y : T) : T = Add x (Negate y)
Def Multiply_left[T : Star, F : Arrow Star Star]<Functor F, Ring T>(x : T, y : F T) : F T = Fmap (Multiply x) y
Def Multiply_right[F : Arrow Star Star, T : Star]<Functor F, Ring T>(x : F T, y : T) : F T = Fmap (z -> Multiply z y) x
Instance Ord{Array N T}<Ord T, Ord_Array N>(Compare = Compare_Array)
Instance Ord{Complex T}<Ord T>(Compare x y = Compare (Pair (Real x) (Imaginary x)) (Pair (Real y) (Imaginary y)))
Instance Ord{Quaternion T}<Ord T>(
  Compare x y = Compare (Pair (Qr x) (Pair (Qx x) (Pair (Qy x) (Qz x)))) (Pair (Qr y) (Pair (Qx y) (Pair (Qy y) (Qz y)))))
Instance Ord{Trivial}(Compare _ _ = EQ)
Instance Ord_Array{!Zr}(Compare_Array _ _ = EQ)
Instance Ord_Array{!Next N}<Ord_Array N>(Compare_Array x y = Compare (Pair (Head x) (Tail x)) (Pair (Head y) (Tail y)))
Def Pow[T : Star]<Field T>(x : T, i : Int) : Maybe T =
  Match Less i 0 {False -> Wrap (Pow' x i), True -> Inverse (Pow' x (Negate i))}
Def Pow'[T : Star]<Ring T>(x : T, i : Int) : T =
  Match i {
    0 -> Identity,
    Default ->
      (z ->
        (Match Mod i 2 {Nothing -> Crash, Wrap j -> Match j {0 -> Id, 1 -> Multiply x, Default -> Crash}}) (Multiply z z))
          (Pow' x (Unsafe (Div i 2)))}
Instance Ring{Complex T}<Ring T>(
  Add = Add',
  Convert x = Complex (Convert x) Zero,
  Multiply x y =
    Complex
      (Minus (Multiply (Real x) (Real y)) (Multiply (Imaginary x) (Imaginary y)))
      (Add (Multiply (Real x) (Imaginary y)) (Multiply (Imaginary x) (Real y))),
  Negate = Negate')
Instance Ring{Trivial}(Add _ = Id, Convert _ = Trivial, Multiply _ = Id, Negate = Id)
Instance Ring{Quaternion T}<Ring T>(
  Add = Add',
  Convert x = Quaternion (Convert x) Zero Zero Zero,
  Multiply x y =
    Quaternion
      (Minus
        (Minus (Minus (Multiply (Qr x) (Qr y)) (Multiply (Qx x) (Qx y))) (Multiply (Qy x) (Qy y)))
        (Multiply (Qz x) (Qz y)))
      (Add
        (Minus (Add (Multiply (Qr x) (Qx y)) (Multiply (Qx x) (Qr y))) (Multiply (Qy x) (Qz y)))
        (Multiply (Qz x) (Qy y)))
      (Minus
        (Add (Add (Multiply (Qr x) (Qy y)) (Multiply (Qx x) (Qz y))) (Multiply (Qy x) (Qr y)))
        (Multiply (Qz x) (Qx y)))
      (Add
        (Add (Minus (Multiply (Qr x) (Qz y)) (Multiply (Qx x) (Qy y))) (Multiply (Qy x) (Qx y)))
        (Multiply (Qz x) (Qr y))),
  Negate = Negate')
Def Sum[F : Arrow Star Star, T : Star]<Foldable F, Ring T> : Function (F T) T = Fold_right Add Zero
Def Sum_squares[F : Arrow Star Star, T : Star]<Foldable F, Functor F, Ring T>(x : F T) : T = Sum (Fmap (y -> Pow' y 2) x)
Instance Writeable{Array N T}<Writeable T, Writeable_Array N>(Write_Brackets = Write_Brackets_Array)
Instance Writeable{Complex T}<Writeable T>(
  Write_Brackets x =
    Pair (Write' (List ("C", "o", "m", "p", "l", "e", "x")) (List (Brackets (Real x), Brackets (Imaginary x)))) True)
Instance Writeable{Fraction}(
  Write_Brackets x =
    Pair (Write' (List ("F", "r", "a", "c", "t", "i", "o", "n")) (List (Brackets (Num x), Brackets (Den x)))) True)
Instance Writeable{Quaternion T}<Writeable T>(
  Write_Brackets x =
    Pair
      (Write'
        (List ("Q", "u", "a", "t", "e", "r", "n", "i", "o", "n"))
        (List (Brackets (Qr x), Brackets (Qx x), Brackets (Qy x), Brackets (Qz x))))
      True)
Instance Writeable{Square N T}<Writeable T, Writeable_Square N>(Write_Brackets = Write_Brackets_Square)
Instance Writeable{Toeplitz N T}<Writeable T, Writeable_Array N>(
  Write_Brackets x = Pair (Cat (List ("T", "o", "e", "p", "l", "i", "t", "z", " ")) (Brackets (Toeplitz' x))) True)
Instance Writeable{Triangle N T}<Writeable T, Writeable_Triangle N>(Write_Brackets = Write_Brackets_Triangle)
Instance Writeable{Trivial}(Write_Brackets _ = Pair (List ("T", "r", "i", "v", "i", "a", "l")) False)
Instance Writeable_Array{!Zr}(
  Write_Brackets_Array _ = Pair (List ("E", "m", "p", "t", "y", "_", "A", "r", "r", "a", "y")) False)
Instance Writeable_Array{!Next N}<Writeable_Array N>(
  Write_Brackets_Array x =
    Pair
      (Write'
        (List ("C", "o", "n", "s", "t", "r", "u", "c", "t", "_", "A", "r", "r", "a", "y"))
        (List (Brackets (Head x), Brackets (Tail x))))
      True)
Instance Writeable_Square{!Zr}(
  Write_Brackets_Square _ = Pair (List ("E", "m", "p", "t", "y", "_", "S", "q", "u", "a", "r", "e")) False)
Instance Writeable_Square{!Next N}<Writeable_Array N, Writeable_Square N>(
  Write_Brackets_Square x =
    Pair
      (Write'
        (List ("C", "o", "n", "s", "t", "r", "u", "c", "t", "_", "S", "q", "u", "a", "r", "e"))
        (List (Brackets (Fst_Square x), Brackets (Top_row_Square x), Brackets (Left_column_Square x), Brackets (Square' x))))
      True)
Instance Writeable_Triangle{!Zr}(
  Write_Brackets_Triangle _ = Pair (List ("E", "m", "p", "t", "y", "_", "T", "r", "i", "a", "n", "g", "l", "e")) False)
Instance Writeable_Triangle{!Next N}<Writeable_Array N, Writeable_Triangle N>(
  Write_Brackets_Triangle x =
    Pair
      (Write'
        (List ("C", "o", "n", "s", "t", "r", "u", "c", "t", "_", "T", "r", "i", "a", "n", "g", "l", "e"))
        (List (Brackets (Fst_Triangle x), Brackets (Top_row_Triangle x), Brackets (Triangle' x))))
      True)
Def Zero[T : Star]<Ring T> : T = Convert 0
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````