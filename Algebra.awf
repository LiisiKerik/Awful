`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Branching Array[!Nat][T : Star](!Zr -> Empty_Array, !Next N -> Construct_Array(Head : T, Tail : Array N T))
Struct Complex[T : Star](Real : T, Imaginary : T)
Struct Diagonal[N : !Nat, T : Star](Diagonal' : Array N T)
Algebraic Either[T : Star, U : Star](Left T, Right U)
`Struct Fraction[T : Star](Numerator : T, Denominator : T)
Algebraic List[T : Star](Empty_List, Construct_List T (List T))
Algebraic Logical(False, True)
Struct Pair[T : Star, U : Star](First : T, Second : U)
~/
Struct Polynomial[T : Star](Coefficients : List T)
`Constructor Polynomial[T : Star]<Commutative T, Ordered T>(Coefficients : List T) = Polynomial (Clean (Coefficients))
/~
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz_triangle[N : !Nat, T : Star](Toeplitz_triangle' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
Struct Trivial
Class Antitail_help'{N : !Nat}(Antitail_help[T : Star] : Function T (Function (Array N T) (Array N T)))
Class Append'{N : !Nat}(Append[T : Star] : Function (Array N T) (Function T (Array (!Next N) T)))
Class Applicative{F : Arrow Star Star}<Functor>(
  Apply[T : Star, U : Star] : Function (F (Function T U)) (Function (F T) (F U)),
  Lift[T : Star] : Function T (F T))
Class Applicative_Array{N : !Nat}<Functor_Array>(
  Apply_Array[T : Star, U : Star] : Function (Array N (Function T U)) (Function (Array N T) (Array N U)),
  Lift_Array[T : Star] : Function T (Array N T))
Class Applicative_Square{N : !Nat}<Functor_Square>(
  Apply_Square[T : Star, U : Star] : Function (Square N (Function T U)) (Function (Square N T) (Square N U)),
  Lift_Square[T : Star] : Function T (Square N T))
Class Applicative_Triangle{N : !Nat}<Functor_Triangle>(
  Apply_Triangle[T : Star, U : Star] : Function (Triangle N (Function T U)) (Function (Triangle N T) (Triangle N U)),
  Lift_Triangle[T : Star] : Function T (Triangle N T))
Class Commutative{T : Star}<Ring>
Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Field_Array{N : !Nat}(Inverse_Array[T : Star]<Field T> : Function (Array N T) (Maybe (Array N T)))
Class Finite{T : Star}<Ordered>(All : List T)
Class Functor{F : Arrow Star Star}(Map[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))
Class Functor_Array{N : !Nat}(Map_Array[T : Star, U : Star] : Function (Function T U) (Function (Array N T) (Array N U)))
Class Functor_Square{N : !Nat}(Map_Square[T : Star, U : Star] : Function (Function T U) (Function (Square N T) (Square N U)))
Class Functor_Triangle{N : !Nat}(
  Map_Triangle[T : Star, U : Star] : Function (Function T U) (Function (Triangle N T) (Triangle N U)))
Class Foldable{F : Arrow Star Star}(
  Fold_right[T : Star, U : Star] : Function (Function T (Function U U)) (Function U (Function (F T) U)))
Class Matrix{F : Arrow !Nat (Arrow Star Star)}(
  Adj[N : !Nat, T : Star]<Commutative T, Matrix_Diagonal N, Matrix_Triangle N> : Function (F N T) (F N T),
  Adj_Det[N : !Nat, T : Star]<Commutative T, Matrix_Diagonal N, Matrix_Triangle N> : Function (F N T) (Pair (F N T) T),
  Characteristic[N : !Nat, T : Star]<Commutative T, Matrix_Diagonal N> : Function (F N T) (Array (!Next N) T),
  Det[N : !Nat, T : Star]<Commutative T, Matrix_Triangle N> : Function (F N T) T,
  Fst[N : !Nat, T : Star] : Function (F (!Next N) T) T,
  Left_column[N : !Nat, T : Star]<Applicative_Array N, Ring T> : Function (F (!Next N) T) (Array N T),
  Matrix'[N : !Nat, T : Star] : Function (F (!Next N) T) (F N T),
  Matrix_by_vector[N : !Nat, T : Star]<Applicative_Array N, Matrix_Square N, Matrix_Triangle N, Ring T> :
    Function (F N T) (Function (Array N T) (Array N T)),
  Top_row[N : !Nat, T : Star]<Applicative_Array N, Ring T> : Function (F (!Next N) T) (Array N T),
  Vector_by_matrix[N : !Nat, T : Star]<Applicative_Array N, Matrix_Square N, Matrix_Triangle N, Ring T> :
    Function (Array N T) (Function (F N T) (Array N T)))
Class Matrix_Diagonal{N : !Nat}(
  Adj_Diagonal[T : Star]<Commutative T> : Function (Array N T) (Array N T),
  Characteristic_Diagonal[T : Star]<Commutative T> : Function (Array N T) (Array (!Next N) T))
Class Matrix_Square{N : !Nat}(
  Matrix_by_vector_Square[T : Star]<Ring T> : Function (Square N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix_Square[T : Star]<Ring T> : Function (Array N T) (Function (Square N T) (Array N T)))
Class Matrix_product'{N : !Nat}(
  Matrix_product[T : Star]<Ring T> : Function (Array N T) (Function (Array N T) (Square N T)))
Class Matrix_Triangle{N : !Nat}(
  Det_Triangle[T : Star]<Commutative T> : Function (Triangle N T) T,
  Matrix_by_vector_Triangle[T : Star]<Ring T> : Function (Triangle N T) (Function (Array N T) (Array N T)),
  Vector_by_matrix_Triangle[T : Star]<Ring T> : Function (Array N T) (Function (Triangle N T) (Array N T)))
Class Monad{F : Arrow Star Star}<Applicative>(Bind[T : Star, U : Star] : Function (F T) (Function (Function T (F U)) (F U)))
Class Ordered{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Ring_Square{N : !Nat}(
  Convert_Square[T : Star]<Ring T> : Function Int (Square N T),
  Multiply_Square[T : Star]<Ring T> : Function (Square N T) (Function (Square N T) (Square N T)))
Class Ring_Toeplitz_triangle{N : !Nat}(
  Convert_Toeplitz_triangle[T : Star]<Ring T> : Function Int (Array N T),
  Multiply_Toeplitz_triangle[T : Star]<Ring T> : Function (Array N T) (Function (Array N T) (Array N T)))
Class Ring_Triangle{N : !Nat}(
  Convert_Triangle[T : Star]<Ring T> : Function Int (Triangle N T),
  Multiply_Triangle[T : Star]<Ring T> : Function (Triangle N T) (Function (Triangle N T) (Triangle N T)))
Class Writeable{T : Star}(Brackets : Function T (List Char), Write : Function T (List Char))
Def Add'[F : Arrow Star Star, T : Star]<Applicative F, Ring T> : Function (F T) (Function (F T) (F T)) = Zip Add
Def Add_Lists[T : Star]<Ring T>(l : List T, m : List T) : List T =
  Match l {
    Empty_List -> m,
    Construct_List x n -> Match m {Empty_List -> l, Construct_List y o -> Construct_List (Add x y) (Add_Lists n o)}}
Def Antitail[N : !Nat, T : Star]<Antitail_help' N>(a : Array (!Next N) T) : Array N T = Antitail_help (Head a) (Tail a)
Instance Antitail_help'{!Zr}(Antitail_help _ _ = Empty_Array)
Instance Antitail_help'{!Next N}<Antitail_help' N>(Antitail_help x a = Construct_Array x (Antitail a))
Instance Append'{!Zr}(Append _ = Lift)
Instance Append'{!Next N}<Append' N>(Append x y = Construct_Array (Head x) (Append (Tail x) y))
Instance Applicative{Array N}<Applicative_Array N>(Apply = Apply_Array, Lift = Lift_Array)
Instance Applicative{Complex}(Apply c d = Complex (Real c (Real d)) (Imaginary c (Imaginary d)), Lift x = Complex x x)
Instance Applicative{Diagonal N}<Applicative_Array N>(
  Apply d e = Diagonal (Apply (Diagonal' d) (Diagonal' e)),
  Lift x = Diagonal (Lift x))
Instance Applicative{Either _}(Apply d e = Match d {Left x -> Left x, Right f -> Map f e}, Lift = Right)
Instance Applicative{Function _}(Apply f g x = f x (g x), Lift x _ = x)
Instance Applicative{List}(
  Apply l m = Match l {Construct_List f n -> Concatenate (Map f m) (Apply n m), Empty_List -> Empty_List},
  Lift x = Construct_List x Empty_List)
Instance Applicative{Maybe}(Apply m n = Match m {Nothing -> Nothing, Wrap f -> Map f n}, Lift = Wrap)
Instance Applicative{Quaternion}(
  Apply q r = Quaternion (Qr q (Qr r)) (Qx q (Qx r)) (Qy q (Qy r)) (Qz q (Qz r)),
  Lift x = Quaternion x x x x)
Instance Applicative{Square N}<Applicative_Square N>(Apply = Apply_Square, Lift = Lift_Square)
Instance Applicative{Toeplitz_triangle N}<Applicative_Array N>(
  Apply d e = Toeplitz_triangle (Apply (Toeplitz_triangle' d) (Toeplitz_triangle' e)),
  Lift x = Toeplitz_triangle (Lift x))
Instance Applicative{Triangle N}<Applicative_Triangle N>(Apply = Apply_Triangle, Lift = Lift_Triangle)
Instance Applicative_Array{!Zr}(Apply_Array _ _ = Empty_Array, Lift_Array _ = Empty_Array)
Instance Applicative_Array{!Next N}<Applicative_Array N>(
  Apply_Array a b = Construct_Array (Head a (Head b)) (Apply (Tail a) (Tail b)),
  Lift_Array x = Construct_Array x (Lift x))
Instance Applicative_Square{!Zr}(Apply_Square _ _ = Empty_Square, Lift_Square _ = Empty_Square)
Instance Applicative_Square{!Next N}<Applicative_Array N, Applicative_Square N>(
  Apply_Square x y =
    Construct_Square
      (Fst x (Fst y))
      (Apply (Top_row_Square x) (Top_row_Square y))
      (Apply (Left_column_Square x) (Left_column_Square y))
      (Apply (Matrix' x) (Matrix' y)),
  Lift_Square x = Construct_Square x (Lift x) (Lift x) (Lift x))
Instance Applicative_Triangle{!Zr}(Apply_Triangle _ _ = Empty_Triangle, Lift_Triangle _ = Empty_Triangle)
Instance Applicative_Triangle{!Next N}<Applicative_Array N, Applicative_Triangle N>(
  Apply_Triangle x y =
    Construct_Triangle
      (Fst x (Fst y))
      (Apply (Top_row_Triangle x) (Top_row_Triangle y))
      (Apply (Matrix' x) (Matrix' y)),
  Lift_Triangle x = Construct_Triangle x (Lift x) (Lift x))
Def Brackets'[T : Star]<Writeable T>(x : T) : List Char = Construct_List "(" (Concatenate (Write x) (Lift ")"))
Def Clean[T : Star]<Ordered T, Ring T>(c : List T) : List T =
  Match c {
    Empty_List -> Empty_List,
    Construct_List x c' ->
      Match Clean c' {Empty_List -> Match Is_zero x {False -> Empty_List, True -> Lift x}, Construct_List _ _ -> c}}
Instance Commutative{Array N T}<Applicative_Array N, Commutative T>
Instance Commutative{Complex T}<Commutative T>
Instance Commutative{Diagonal N T}<Applicative_Array N, Commutative T>
`Instance Commutative{Fraction T}<Commutative T>
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
`Instance Commutative{Polynomial T}<Commutative T, Ordered T>
Instance Commutative{Toeplitz_triangle N T}<Applicative_Array N, Commutative T, Ring_Toeplitz_triangle N>
Instance Commutative{Trivial}
Def Compare'[T : Star, U : Star]<Ordered T, Ordered U>(x : T, y : T, a : U, b : U) : Comparison =
  Match Compare x y {LT -> LT, EQ -> Compare a b, GT -> GT}
Def Concatenate[T : Star](l : List T, m : List T) : List T = Match l {
  Construct_List x n -> Construct_List x (Concatenate n m),
  Empty_List -> m}
Def Div'[T : Star](x : T, y : T) : T = First (Div_Rem' x y)
Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T = Multiply (Inverse x) (Wrap y)
Def Div_left'[T : Star, F : Arrow Star Star]<Functor F, Field T>(x : T, y : F T) : Maybe (F T) =
  Map (z -> Multiply_left z y) (Inverse x)
Def Div_Rem'[T : Star](x : T, y : T) : Pair T T = Crash
Def Div_right[T : Star]<Field T>(x : T, y : T) : Maybe T = Map (Multiply x) (Inverse y)
Def Div_right'[F : Arrow Star Star, T : Star]<Functor F, Field T>(x : F T, y : T) : Maybe (F T) =
  Map (Multiply_right x) (Inverse y)
Def Dot_product[N : !Nat, T : Star]<Applicative_Array N, Ring T>(x : Array N T, y : Array N T) : T = Sum (Multiply x y)
Def Equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> True, Default -> False}
Instance Field{Array N T}<Applicative_Array N, Field_Array N, Field T>(Inverse = Inverse_Array)
Instance Field{Complex T}<Commutative T, Field T>(
  Inverse x = Div_right' (Complex (Real x) (Negate (Imaginary x))) (Sum_squares x))
Instance Field{Diagonal N T}<Applicative_Array N, Field_Array N, Field T>(Inverse x = Map Diagonal (Inverse (Diagonal' x)))
~/
Instance Field{Fraction T}<Commutative T, Ordered T>(
  Inverse x = Match Is_zero (Numerator x) {False -> Wrap (Fraction (Denominator x) (Numerator x)), True -> Nothing})
/~
Instance Field{Int}(Inverse x = Match x {-1 -> Wrap -1, 1 -> Wrap 1, Default -> Nothing})
Instance Field{Logical}(Inverse x = Match x {False -> Nothing, True -> Wrap True})
Instance Field{Pair T U}<Field T, Field U>(Inverse x = Zip Pair (Inverse (First x)) (Inverse (Second x)))
~/
Instance Field{Polynomial T}<Commutative T, Field T, Ordered T>(
  Inverse x =
    Match Coefficients x {
      Empty_List -> Nothing,
      Construct_List y z ->
        Match z {Empty_List -> Map (a -> Polynomial (Lift a)) (Inverse y), Construct_List _ _ -> Nothing}})
/~
Instance Field{Quaternion T}<Commutative T, Field T>(
  Inverse x = Div_right' (Quaternion (Qr x) (Negate (Qx x)) (Negate (Qy x)) (Negate (Qz x))) (Sum_squares x))
Instance Field{Square N T}<Applicative_Square N, Ring_Square N, Commutative T, Field T>(Inverse = Crash)
Instance Field{Toeplitz_triangle N T}<Applicative_Array N, Field T, Ring_Toeplitz_triangle N>(Inverse = Crash)
Instance Field{Triangle N T}<Applicative_Triangle N, Field T, Ring_Triangle N>(Inverse = Crash)
Instance Field{Trivial}(Inverse = Wrap)
Instance Field_Array{!Zr}(Inverse_Array = Wrap)
Instance Field_Array{!Next N}<Applicative_Array N, Field_Array N>(
  Inverse_Array x = Zip Construct_Array (Inverse (Head x)) (Inverse (Tail x)))
Def Filter_List[T : Star](f : Function T Logical, x : List T) : List T = Match x {
  Construct_List y z -> (w -> Match f y {
    False -> w,
    True -> Construct_List y w}) (Filter_List f z),
  Empty_List -> Empty_List}
Instance Finite{Array N T}<Finite T>(All = Crash)
Instance Finite{Comparison}(All = Construct_List LT (Construct_List EQ (Construct_List GT Empty_List)))
Instance Finite{Complex T}<Finite T>(All = Zip Complex All All)
Instance Finite{Diagonal _ T}<Finite T>(All = Map Diagonal All)
Instance Finite{Either T U}<Finite T, Finite U>(All = Concatenate (Map Left All) (Map Right All))
`Instance Finite{Fraction T}<Commutative T, Finite T>(All = Crash)
Instance Finite{Function T U}<Finite T, Finite U>(All = Crash)
Instance Finite{Logical}(All = Construct_List False (Construct_List True Empty_List))
Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Pair All All)
`Instance Finite{Polynomial T}<Commutative T, Finite T, Ordered T>(All = Crash)
Instance Finite{Quaternion T}<Finite T>(All = Apply (Apply (Zip Quaternion All All) All) All)
Instance Finite{Square N T}<Finite T>(All = Crash)
Instance Finite{Toeplitz_triangle _ T}<Finite T>(All = Map Toeplitz_triangle All)
Instance Finite{Triangle N T}<Finite T>(All = Crash)
Instance Finite{Trivial}(All = Lift Trivial)
Def Flatten[F : Arrow Star Star, T : Star]<Monad F>(x : F (F T)) : F T = Bind x Id
~/
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz_triangle[N : !Nat, T : Star](Toeplitz_triangle' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
Struct Trivial
/~
Instance Foldable{Array N}(Fold_right = Crash)
Instance Foldable{Complex}(Fold_right f x y = f (Real y) (f (Imaginary y) x))
Instance Foldable{Diagonal N}(Fold_right f x y = Fold_right f x (Diagonal' y))
Instance Foldable{List}(Fold_right f x y = Match y {Empty_List -> x, Construct_List z a -> f z (Fold_right f x a)})
Instance Foldable{Maybe}(Fold_right f x y = Match y {Nothing -> x, Wrap z -> f z x})
Instance Foldable{Quaternion}(Fold_right f x y = f (Qr y) (f (Qx y) (f (Qy y) (f (Qz y) x))))
Instance Functor{Array N}<Functor_Array N>(Map = Map_Array)
Instance Functor{Complex}(Map f c = Complex (f (Real c)) (f (Imaginary c)))
Instance Functor{Diagonal N}<Functor_Array N>(Map f d = Diagonal (Map f (Diagonal' d)))
Instance Functor{Either _}(Map f x = Match x {Left y -> Left y, Right y -> Right (f y)})
Instance Functor{Function _}(Map f g x = f (g x))
Instance Functor{List}(Map f l = Match l {Empty_List -> Empty_List, Construct_List x m -> Construct_List (f x) (Map f m)})
Instance Functor{Maybe}(Map f m = Match m {Nothing -> Nothing, Wrap x -> Wrap (f x)})
Instance Functor{Pair _}(Map f x = Pair (First x) (f (Second x)))
Instance Functor{Quaternion}(Map f q = Quaternion (f (Qr q)) (f (Qx q)) (f (Qy q)) (f (Qz q)))
Instance Functor{Square N}<Functor_Square N>(Map = Map_Square)
Instance Functor{Toeplitz_triangle N}<Functor_Array N>(Map f t = Toeplitz_triangle (Map f (Toeplitz_triangle' t)))
Instance Functor{Triangle N}<Functor_Triangle N>(Map = Map_Triangle)
Instance Functor_Array{!Zr}(Map_Array _ _ = Empty_Array)
Instance Functor_Array{!Next N}<Functor_Array N>(Map_Array f a = Construct_Array (f (Head a)) (Map f (Tail a)))
Instance Functor_Square{!Zr}(Map_Square _ _ = Empty_Square)
Instance Functor_Square{!Next N}<Functor_Array N, Functor_Square N>(
  Map_Square f s =
    Construct_Square (f (Fst s)) (Map f (Top_row_Square s)) (Map f (Left_column_Square s)) (Map f (Matrix' s)))
Instance Functor_Triangle{!Zr}(Map_Triangle _ _ = Empty_Triangle)
Instance Functor_Triangle{!Next N}<Functor_Array N, Functor_Triangle N>(
  Map_Triangle f t = Construct_Triangle (f (Fst t)) (Map f (Top_row_Triangle t)) (Map f (Matrix' t)))
Def Greater[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {GT -> True, Default -> False}
Def Greater_or_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {LT -> False, Default -> True}
Def Id[T : Star](x : T) : T = x
Def Identity[T : Star]<Ring T> : T = Convert 0
Def Is_zero[T : Star]<Ordered T, Ring T> : Function T Logical = Equal Zero
Def Less[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {LT -> True, Default -> False}
Def Less_or_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {GT -> False, Default -> True}
~/
Def Map_Polynomial[T : Star, U : Star]<Commutative T, Commutative U, Ordered T, Ordered U>
  (f : Function T U, x : Polynomial T) : Polynomial U =
    Polynomial (Map f (Coefficients x))
/~
Instance Matrix{Diagonal}(
  Adj x = Diagonal (Adj_Diagonal (Diagonal' x)),
  Adj_Det x = Pair (Adj x) (Det x),
  Characteristic x = Characteristic_Diagonal (Diagonal' x),
  Det x = Product_right (Diagonal' x),
  Fst d = Head (Diagonal' d),
  Left_column _ = Zero,
  Matrix' d = Diagonal (Tail (Diagonal' d)),
  Matrix_by_vector x = Multiply (Diagonal' x),
  Top_row _ = Zero,
  Vector_by_matrix x y = Multiply x (Diagonal' y))
Instance Matrix{Square}(
  Adj x = Crash,
  Adj_Det x = Crash,
  Characteristic x = Crash,
  Det d = Crash,
  Fst = Fst_Square,
  Left_column = Left_column_Square,
  Matrix' = Square',
  Matrix_by_vector = Matrix_by_vector_Square,
  Top_row = Top_row_Square,
  Vector_by_matrix = Vector_by_matrix_Square)
Instance Matrix{Triangle}(
  Adj x = Crash,
  Adj_Det x = Crash,
  Characteristic x = Crash,
  Det = Det_Triangle,
  Fst = Fst_Triangle,
  Left_column _ = Zero,
  Matrix' = Triangle',
  Matrix_by_vector = Matrix_by_vector_Triangle,
  Top_row = Top_row_Triangle,
  Vector_by_matrix = Vector_by_matrix_Triangle)
Instance Matrix_Diagonal{!Zr}(Adj_Diagonal = Id, Characteristic_Diagonal _ = Identity)
Instance Matrix_Diagonal{!Next N}<Append' N, Applicative_Array N, Functor_Array N, Matrix_Diagonal N>(
  Adj_Diagonal x = Construct_Array (Product_right (Tail x)) (Multiply_left (Head x) (Adj_Diagonal (Tail x))),
  Characteristic_Diagonal x = Shift_difference (Head x) (Characteristic_Diagonal (Tail x)))
Instance Matrix_Square{!Zr}(Matrix_by_vector_Square _ = Id, Vector_by_matrix_Square _ _ = Empty_Array)
Instance Matrix_Square{!Next N}<Applicative_Array N, Matrix_Square N, Matrix_Triangle N>(
  Matrix_by_vector_Square x y =
    Construct_Array
      (Dot_product (Construct_Array (Fst x) (Top_row x)) y)
      (Add (Multiply_right (Left_column x) (Head y)) (Matrix_by_vector (Matrix' x) (Tail y))),
  Vector_by_matrix_Square x y =
    Construct_Array
      (Dot_product x (Construct_Array (Fst y) (Left_column y)))
      (Add (Multiply_left (Head x) (Top_row y)) (Vector_by_matrix (Tail x) (Matrix' y))))
Instance Matrix_Triangle{!Zr}(
  Det_Triangle _ = Identity,
  Matrix_by_vector_Triangle _ = Id,
  Vector_by_matrix_Triangle _ _ = Empty_Array)
Instance Matrix_Triangle{!Next N}<Applicative_Array N, Matrix_Square N, Matrix_Triangle N>(
  Det_Triangle x = Multiply (Fst x) (Det_Triangle (Matrix' x)),
  Matrix_by_vector_Triangle x y =
    Construct_Array (Dot_product (Construct_Array (Fst x) (Top_row x)) y) (Matrix_by_vector (Matrix' x) (Tail y)),
  Vector_by_matrix_Triangle x y =
    Add
      (Multiply_left (Head x) (Construct_Array (Fst y) (Top_row y)))
      (Construct_Array Zero (Vector_by_matrix (Tail x) (Matrix' y))))
Instance Matrix_product'{!Zr}(Matrix_product _ _ = Empty_Square)
Instance Matrix_product'{!Next N}<Applicative_Array N, Matrix_product' N>(
  Matrix_product x y =
    Construct_Square
      (Multiply (Head x) (Head y))
      (Multiply_left (Head x) (Tail y))
      (Multiply_right (Tail x) (Head y))
      (Matrix_product (Tail x) (Tail y)))
Def Minus[T : Star]<Ring T>(x : T, y : T) : T = Add x (Negate y)
Instance Monad{List}(Bind l f = Match l {Empty_List -> Empty_List, Construct_List x m -> Concatenate (f x) (Bind m f)})
Def Multiply_Lists[T : Star]<Commutative T>(x : List T, y : List T) : List T =
  Match x {
    Empty_List -> Empty_List,
    Construct_List a b ->
      Match y {
        Empty_List -> Empty_List,
        Construct_List c d ->
          Construct_List
            (Multiply a c)
            (Add_Lists (Add_Lists (Multiply_left a d) (Multiply_right b c)) (Multiply_Lists b d))}}
Def Multiply_left[T : Star, F : Arrow Star Star]<Functor F, Ring T>(x : T, y : F T) : F T = Map (Multiply x) y
Def Multiply_right[F : Arrow Star Star, T : Star]<Functor F, Ring T>(x : F T, y : T) : F T = Map (z -> Multiply z y) x
Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}
Def Negate'[F : Arrow Star Star, T : Star]<Functor F, Ring T> : Function (F T) (F T) = Map Negate
Def Not_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> False, Default -> True}
~/
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz_triangle[N : !Nat, T : Star](Toeplitz_triangle' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
/~
Instance Ordered{Array N T}<Ordered T>(Compare = Crash)
Instance Ordered{Char}(Compare = Compare_Char)
Instance Ordered{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, Default -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, Default -> GT}})
Instance Ordered{Complex T}<Ordered T>(Compare x y = Compare' (Real x) (Real y) (Imaginary x) (Imaginary y))
Instance Ordered{Diagonal N T}<Ordered T>(Compare x y = Compare (Diagonal' x) (Diagonal' y))
Instance Ordered{Either T U}<Ordered T, Ordered U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right -> LT},
      Right z -> Match y {Left -> GT, Right w -> Compare z w}})
Instance Ordered{Function T U}<Finite T, Ordered U>(Compare f g = Compare (Map f All) (Map g All))
Instance Ordered{Int}(Compare = Compare_Int)
Instance Ordered{List T}<Ordered T>(
  Compare x y =
    Match x {
      Construct_List z w ->
        Match y {Construct_List a b -> (c -> Match c {EQ -> Compare w b, Default -> c}) (Compare z a), Empty_List -> GT},
      Empty_List -> Match y {Construct_List -> LT, Empty_List -> EQ}})
Instance Ordered{Logical}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Instance Ordered{Maybe T}<Ordered T>(
  Compare x y =
    Match x {Nothing -> Match y {Nothing -> EQ, Wrap -> LT}, Wrap z -> Match y {Nothing -> GT, Wrap w -> Compare z w}})
Instance Ordered{Pair T U}<Ordered T, Ordered U>(Compare x y = Compare' (First x) (First y) (Second x) (Second y))
Instance Ordered{Quaternion T}<Ordered T>(
  Compare x y =
    Match Compare (Qr x) (Qr y) {
      LT -> LT,
      EQ -> Match Compare (Qx x) (Qx y) {LT -> LT, EQ -> Compare' (Qy x) (Qy y) (Qz x) (Qz y), GT -> GT},
      GT -> GT})
Instance Ordered{Square N T}(Compare = Crash)
Instance Ordered{Toeplitz_triangle N T}<Ordered T>(Compare x y = Compare (Toeplitz_triangle' x) (Toeplitz_triangle' y))
Instance Ordered{Triangle N T}(Compare = Crash)
Instance Ordered{Trivial}(Compare _ _ = EQ)
Def Pow[T : Star]<Field T>(x : T, i : Int) : Maybe T =
  Match Less i 0 {False -> Wrap (Pow' x i), True -> Inverse (Pow' x (Negate i))}
Def Pow'[T : Star]<Ring T>(x : T, i : Int) : T =
  Match i {
    0 -> Identity,
    Default ->
      (y -> (z -> (Match Second y {0 -> Id, 1 -> Multiply x, Default -> Crash}) (Multiply z z)) (Pow' x (First y)))
        (Div_Rem' i 2)}
Def Product_right[F : Arrow Star Star, T : Star]<Foldable F, Ring T> : Function (F T) T = Fold_right Multiply Identity
Def Rem'[T : Star](x : T, y : T) : T = Second (Div_Rem' x y)
Instance Ring{Array N T}<Applicative_Array N, Ring T>(
  Add = Add',
  Convert x = Lift (Convert x),
  Multiply = Zip Multiply,
  Negate = Negate')
Instance Ring{Complex T}<Ring T>(
  Add = Add',
  Convert x = Complex (Convert x) Zero,
  Multiply x y =
    Complex
      (Minus (Multiply (Real x) (Real y)) (Multiply (Imaginary x) (Imaginary y)))
      (Add (Multiply (Real x) (Imaginary y)) (Multiply (Imaginary x) (Real y))),
  Negate = Negate')
Instance Ring{Diagonal N T}<Applicative_Array N, Ring T>(
  Add = Add',
  Convert x = Lift (Convert x),
  Multiply d e = Diagonal (Multiply (Diagonal' d) (Diagonal' e)),
  Negate = Negate')
~/
Instance Ring{Fraction T}<Commutative T>(
  Add x y =
    Fraction
      (Add (Multiply (Numerator x) (Denominator y)) (Multiply (Denominator x) (Numerator y)))
      (Multiply (Denominator x) (Denominator y)),
  Convert x = Fraction (Convert x) Identity,
  Multiply x y = Fraction (Multiply (Numerator x) (Numerator y)) (Multiply (Denominator x) (Denominator y)),
  Negate x = Fraction (Negate (Numerator x)) (Denominator x))
/~
Instance Ring{Int}(Add = Add_Int, Convert = Id, Multiply = Multiply_Int, Negate = Negate_Int)
Instance Ring{Logical}(
  Add = Not_equal,
  Convert x = Equal (Rem' x 2) 1,
  Multiply x y = Match x {False -> False, True -> y},
  Negate = Id)
Instance Ring{Maybe T}<Ring T>(Add = Add', Convert x = Wrap (Convert x), Multiply = Zip Multiply, Negate = Negate')
Instance Ring{Pair T U}<Ring T, Ring U>(
  Add x y = Pair (Add (First x) (First y)) (Add (Second x) (Second y)),
  Convert x = Pair (Convert x) (Convert x),
  Multiply x y = Pair (Multiply (First x) (First y)) (Multiply (Second x) (Second y)),
  Negate x = Pair (Negate (First x)) (Negate (Second x)))
~/
Instance Ring{Polynomial T}<Commutative T, Ordered T>(
  Add p q = Polynomial (Multiply_Lists (Coefficients p) (Coefficients q)),
  Convert i = Polynomial (Lift (Convert i)),
  Multiply p q = Polynomial (Add_Lists (Coefficients p) (Coefficients q)),
  Negate = Map_Polynomial Negate)
/~
Instance Ring{Quaternion T}<Ring T>(
  Add = Add',
  Convert x = Quaternion (Convert x) Zero Zero Zero,
  Multiply q r =
    Quaternion
      (Minus
        (Minus (Minus (Multiply (Qr q) (Qr r)) (Multiply (Qx q) (Qx r))) (Multiply (Qy q) (Qy r)))
        (Multiply (Qz q) (Qz r)))
      (Add
        (Minus (Add (Multiply (Qr q) (Qx r)) (Multiply (Qx q) (Qr r))) (Multiply (Qy q) (Qz r)))
        (Multiply (Qz q) (Qy r)))
      (Minus
        (Add (Add (Multiply (Qr q) (Qy r)) (Multiply (Qx q) (Qz r))) (Multiply (Qy q) (Qr r)))
        (Multiply (Qz q) (Qx r)))
      (Add
        (Add (Minus (Multiply (Qr q) (Qz r)) (Multiply (Qx q) (Qy r))) (Multiply (Qy q) (Qx r)))
        (Multiply (Qz q) (Qr r))),
  Negate = Negate')
Instance Ring{Square N T}<Applicative_Square N, Ring T, Ring_Square N>(
  Add = Add',
  Convert = Convert_Square,
  Multiply = Multiply_Square,
  Negate = Negate')
Instance Ring{Toeplitz_triangle N T}<Applicative_Array N, Ring T, Ring_Toeplitz_triangle N>(
  Add = Add',
  Convert i = Toeplitz_triangle (Convert_Toeplitz_triangle i),
  Multiply x y = Toeplitz_triangle (Multiply_Toeplitz_triangle (Toeplitz_triangle' x) (Toeplitz_triangle' y)),
  Negate = Negate')
Instance Ring{Triangle N T}<Applicative_Triangle N, Ring T, Ring_Triangle N>(
  Add = Add',
  Convert = Convert_Triangle,
  Multiply = Multiply_Triangle,
  Negate = Negate')
Instance Ring{Trivial}(Add _ = Id, Convert _ = Trivial, Multiply _ = Id, Negate = Id)
Instance Ring_Square{!Zr}(Convert_Square _ = Empty_Square, Multiply_Square _ _ = Empty_Square)
Instance Ring_Square{!Next N}
  <Applicative_Array N, Applicative_Square N, Matrix_Square N, Matrix_Triangle N, Matrix_product' N, Ring_Square N>(
    Convert_Square i = Construct_Square (Convert i) Zero Zero (Convert i),
    Multiply_Square x y =
      Construct_Square
        (Add (Multiply (Fst x) (Fst y)) (Dot_product (Top_row x) (Left_column y)))
        (Add (Multiply_left (Fst x) (Top_row y)) (Vector_by_matrix (Top_row x) (Matrix' y)))
        (Add (Multiply_right (Left_column x) (Fst y)) (Matrix_by_vector (Matrix' x) (Left_column y)))
        (Add (Matrix_product (Left_column x) (Top_row x)) (Multiply (Matrix' x) (Matrix' y))))
Instance Ring_Toeplitz_triangle{!Zr}(Convert_Toeplitz_triangle _ = Empty_Array, Multiply_Toeplitz_triangle _ _ = Empty_Array)
Instance Ring_Toeplitz_triangle{!Next N}<Antitail_help' N, Applicative_Array N, Ring_Toeplitz_triangle N>(
  Convert_Toeplitz_triangle i = Construct_Array (Convert i) Zero,
  Multiply_Toeplitz_triangle x y =
    Construct_Array
      (Multiply (Head x) (Head y))
      (Add (Multiply_left (Head x) (Tail y)) (Multiply_Toeplitz_triangle (Tail x) (Antitail y))))
Instance Ring_Triangle{!Zr}(Convert_Triangle _ = Empty_Triangle, Multiply_Triangle _ = Id)
Instance Ring_Triangle{!Next N}<Applicative_Array N, Applicative_Triangle N, Ring_Triangle N>(
  Convert_Triangle i = Construct_Triangle (Convert i) Zero (Convert i),
  Multiply_Triangle x y = Construct_Triangle (Multiply (Fst x) (Fst y)) Crash (Multiply (Matrix' x) (Matrix' y)))
Def Shift_difference[T : Star, N : !Nat]<Append' N, Applicative_Array N, Functor_Array N, Ring T>(x : T, y : Array N T) :
  Array (!Next N) T =
    Minus (Construct_Array Zero y) (Append (Multiply_left x y) Zero)
Def Sum[F : Arrow Star Star, T : Star]<Foldable F, Ring T> : Function (F T) T = Fold_right Add Zero
Def Sum_squares[F : Arrow Star Star, T : Star]<Foldable F, Functor F, Ring T>(x : F T) : T = Sum (Map (y -> Pow' y 2) x)
Def Write'(l : List (List Char)) : List Char =
  Match l {Empty_List -> Empty_List, Construct_List m n -> Concatenate m (Flatten (Map (Construct_List " ") n))}
Instance Writeable{Complex T}<Writeable T>(
  Brackets = Brackets',
  Write c = Construct_List " " (Concatenate (Brackets (Real c)) (Construct_List " " (Brackets (Imaginary c)))))
Instance Writeable{Logical}(
  Brackets = Write,
  Write x =
    Match x {
      False ->
        Construct_List "F" (Construct_List "a" (Construct_List "l" (Construct_List "s" (Construct_List "e" Empty_List)))),
      True -> Construct_List "T" (Construct_List "r" (Construct_List "u" (Construct_List "e" Empty_List)))})
Instance Writeable{Trivial}(
  Brackets = Write,
  Write _ =
    Construct_List
      "T"
      (Construct_List
        "r"
        (Construct_List "i" (Construct_List "v" (Construct_List "i" (Construct_List "a" (Construct_List "l" Empty_List)))))))
Def Zero[T : Star]<Ring T> : T = Convert 0
Def Zip[F : Arrow Star Star, T : Star, U : Star, V : Star]<Applicative F>(f : Function T (Function U V), x : F T) :
  Function (F U) (F V) =
    Apply (Map f x)
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````