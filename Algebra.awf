Load Either.awf
Load Finite.awf
Load Logical.awf
Load List.awf
Load Ord.awf
Load Pair.awf
Load Ring.awf
Load Standard.awf
Branching Array[T : Star](!Zr -> Empty_Array, !Next N -> Construct_Array(Head : T, Tail : Array N T))
Struct Fraction(Num : Int, Den : Int)
Branching Square[T : Star](
  !Zr -> Empty_Square,
  !Next N -> Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz[N : !Nat, T : Star](Toeplitz' : Array N T)
Branching Triangle[T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
Class Finite_Array{N : !Nat}<Ord_Array>(All_Array[T : Star]<Finite T> : List (Array N T))
Class Foldable{F : Star -> Star}(Fold_right[T : Star, U : Star] : (T -> U -> U) -> U -> F T -> U)
Class Functor_Array{N : !Nat}(Fmap_Array[T : Star, U : Star] : (T -> U) -> Array N T -> Array N U)
Class Mat{F : !Nat -> Star -> Star}(
  Adj[N : !Nat, T : Star]<Commutative T> : F N T -> F N T,
  Adj_Det[N : !Nat, T : Star]<Commutative T> : F N T -> Pair (F N T) T,
  Characteristic[N : !Nat, T : Star]<Commutative T> : F N T -> Array (!Next N) T,
  Det[N : !Nat, T : Star]<Commutative T> : F N T -> T,
  Matrix_by_vector[N : !Nat, T : Star]<Ring T> : F N T -> Array N T -> Array N T,
  Vector_by_matrix[N : !Nat, T : Star]<Ring T> : Array N T -> F N T -> Array N T)
Class Ord_Array{N : !Nat}(Compare_Array[T : Star]<Ord T> : Array N T -> Array N T -> Comparison)
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Instance Finite{Array N T}<Finite T, Finite_Array N>(All = All_Array)
Instance Finite_Array{!Zr}(All_Array = Return Empty_Array)
Instance Finite_Array{!Next N}<Finite_Array N>(All_Array = Zip Construct_Array All All)
Instance Foldable{Either T}(Fold_right f x y = Match y {Left _ -> x, Right z -> f z x})
Instance Foldable{List}(Fold_right f x y = Match y {Empty_List -> x, Construct_List z a -> f z (Fold_right f x a)})
Instance Foldable{Maybe}(Fold_right f x y = Match y {Nothing -> x, Wrap z -> f z x})
Instance Functor{Array N}<Functor_Array N>(Fmap = Fmap_Array)
Instance Functor_Array{!Zr}(Fmap_Array _ _ = Empty_Array)
Instance Functor_Array{!Next N}<Functor_Array N>(Fmap_Array f a = Construct_Array (f (Head a)) (Fmap f (Tail a)))
Def Multiply_left[T : Star, F : Star -> Star]<Functor F, Ring T>(x : T, y : F T) : F T = Fmap (Multiply x) y
Def Multiply_right[F : Star -> Star, T : Star]<Functor F, Ring T>(x : F T, y : T) : F T = Fmap (z -> z * y) x
Instance Ord{Array N T}<Ord T, Ord_Array N>(Compare = Compare_Array)
Instance Ord_Array{!Zr}(Compare_Array _ _ = EQ)
Instance Ord_Array{!Next N}<Ord_Array N>(Compare_Array x y = Compare (Pair (Head x) (Tail x)) (Pair (Head y) (Tail y)))
Def Sum[F : Star -> Star, T : Star]<Foldable F, Ring T> : F T -> T = Fold_right Add Zero