`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Branching Array[!Nat][T : Star](!Zr -> Empty_Array, !Next N -> Construct_Array(Head : T, Tail : Array N T))
Struct Complex[T : Star](Real : T, Imaginary : T)
Struct Diagonal[N : !Nat, T : Star](Diagonal' : Array N T)
Algebraic Either[T : Star, U : Star](Left T, Right U)
Struct Fraction[T : Star](Numerator : T, Denominator : T)
Algebraic List[T : Star](Empty_List, Construct_List T (List T))
Algebraic Logical(False, True)
Struct Pair[T : Star, U : Star](First : T, Second : U)
Struct Polynomial[T : Star](Coefficients : List T)
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_Row_Square : Array N T, Left_Column_Square : Array N T, Square' : Square N T))
Branching Toeplitz[!Nat][T : Star](
  !Zr -> Empty_Toeplitz,
  !Next N -> Construct_Toeplitz(Fst_Toeplitz : T, Top_Row_Toeplitz : Array N T, Left_Column_Toeplitz : Array N T))
Struct Toeplitz_Triangle[N : !Nat, T : Star](Toeplitz_Triangle' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_Row_Triangle : Array N T, Triangle' : Triangle N T))
Struct Trivial
Class Applicative{F : Arrow Star Star}<Functor>(
  Apply[T : Star, U : Star] : Function (F (Function T U)) (Function (F T) (F U)),
  Lift[T : Star] : Function T (F T))
Class Commutative{T : Star}<Ring>
Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Finite{T : Star}(All : List T)
Class Functor{F : Arrow Star Star}(Map[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))
~/
Class Matrix{F : Arrow !Nat (Arrow Star Star)}(
  Det[N : !Nat, T : Star]<Ring T> : Function (F N T) T,
  Fst[N : !Nat, T : Star]<Ring T> : Function (F (!Next N) T) T,
  Left_Column[N : !Nat, T : Star]<Ring T> : Function (F (!Next N) T) (Array N T),
  Matrix'[N : !Nat, T : Star]<Ring T> : Function (F (!Next N) T) (F N T),
  Top_Row[N : !Nat, T : Star]<Ring T> : Function (F (!Next N) T) (Array N T))
/~
Class Monad{F : Arrow Star Star}<Applicative>(Bind[T : Star, U : Star] : Function (F T) (Function (Function T (F U)) (F U)))
Class Ordered{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Writeable{T : Star}(Write : Function T (List Char))
Def Add_Lists[T : Star]<Ring T>(l : List T, m : List T) : List T =
  Match l {
    Empty_List -> m,
    Construct_List x n -> Match m {Empty_List -> l, Construct_List y o -> Construct_List (Add x y) (Add_Lists n o)}}
Instance Applicative{Array _}(Apply a b = Crash, Lift = Crash)
Instance Applicative{Complex}(Apply c d = Complex (Real c (Real d)) (Imaginary c (Imaginary d)), Lift x = Complex x x)
Instance Applicative{Either _}(Apply d e = Match d {Left x -> Left x, Right f -> Map f e}, Lift = Right)
Instance Applicative{Function _}(Apply f g x = f x (g x), Lift x _ = x)
Instance Applicative{List}(
  Apply l m = Match l {Construct_List f n -> Concatenate (Map f m) (Apply n m), Empty_List -> Empty_List},
  Lift x = Construct_List x Empty_List)
Instance Applicative{Maybe}(Apply m n = Match m {Nothing -> Nothing, Wrap f -> Map f n}, Lift = Wrap)
Instance Commutative{Complex T}<Commutative T>
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Instance Commutative{Polynomial T}<Commutative T>
Instance Commutative{Trivial}
Def Concatenate[T : Star](l : List T, m : List T) : List T = Match l {
  Construct_List x n -> Construct_List x (Concatenate n m),
  Empty_List -> m}
Def Equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> True, Default -> False}
Instance Field{Complex T}<Commutative T>(Inverse x = Crash)
Instance Field{Int}(Inverse x = Match x {-1 -> Wrap -1, 1 -> Wrap 1, Default -> Nothing})
Instance Field{Pair T U}<Field T, Field U>(
  Inverse x =
    Match Inverse (First x) {
      Nothing -> Nothing,
      Wrap y -> Match Inverse (Second x) {Nothing -> Nothing, Wrap z -> Wrap (Pair y z)}})
Instance Finite{Comparison}(All = Construct_List LT (Construct_List EQ (Construct_List GT Empty_List)))
Instance Finite{Complex T}<Finite T>(All = Zip Complex All All)
Instance Finite{Either T U}<Finite T, Finite U>(All = Concatenate (Map Left All) (Map Right All))
Instance Finite{Logical}(All = Construct_List False (Construct_List True Empty_List))
Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Pair All All)
Instance Finite{Trivial}(All = Construct_List Trivial Empty_List)
`Instance Functor{Array N}(Map f x = !Match N {!Next -> Construct_Array (f (Head x)) (Map f (Tail x)), !Zr -> Empty_Array})
Instance Functor{Array N}(Map f a = Crash)
Instance Functor{Complex}(Map f c = Complex (f (Real c)) (f (Imaginary c)))
Instance Functor{Either _}(Map f x = Match x {Left y -> Left y, Right y -> Right (f y)})
Instance Functor{Function _}(Map f g x = f (g x))
Instance Functor{List}(Map f l = Match l {Empty_List -> Empty_List, Construct_List x m -> Construct_List (f x) (Map f m)})
Instance Functor{Maybe}(Map f m = Match m {Nothing -> Nothing, Wrap x -> Wrap (f x)})
Instance Functor{Pair _}(Map f x = Pair (First x) (f (Second x)))
Def Id[T : Star](x : T) : T = x
Def Identity[T : Star]<Ring T> : T = Convert 0
Def Left_division[T : Star]<Field T>(x : T, y : T) : Maybe T = Map (z -> Multiply z x) (Inverse y)
Def Less[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {LT -> True, Default -> False}
Def Less_or_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {GT -> False, Default -> True}
~/
Instance Matrix{Diagonal}(
  Det d = Crash,
  Fst d = Head (Diagonal' d),
  Left_Column _ = Zero,
  Matrix' d = Tail (Diagonal' d),
  Top_Row _ = Zero)
/~
Def Minus[T : Star]<Ring T>(x : T, y : T) : T = Add x (Negate y)
Def Not(x : Logical) : Logical = Match x {
  False -> True,
  True -> False}
Def Not_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> False, Default -> True}
Instance Ordered{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, Default -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, Default -> GT}})
Instance Ordered{Complex T}<Ordered T>(
  Compare x y = Match Compare (Real x) (Real y) {LT -> LT, EQ -> Compare (Imaginary x) (Imaginary y), GT -> GT})
Instance Ordered{Either T U}<Ordered T, Ordered U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right -> LT},
      Right z -> Match y {Left -> GT, Right w -> Compare z w}})
Instance Ordered{Int}(Compare = Compare_Int)
Instance Ordered{List T}<Ordered T>(
  Compare x y =
    Match x {
      Construct_List z w ->
        Match y {Construct_List a b -> (c -> Match c {EQ -> Compare w b, Default -> c}) (Compare z a), Empty_List -> GT},
      Empty_List -> Match y {Construct_List -> LT, Empty_List -> EQ}})
Instance Ordered{Logical}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Def Right_division[T : Star]<Field T>(x : T, y : T) : Maybe T = Map (Multiply x) (Inverse y)
Instance Ring{Array _ T}<Ring T>(Add a b = Crash, Convert = Crash, Multiply a b = Crash, Negate = Crash)
Instance Ring{Complex T}<Ring T>(
  Add x y = Complex (Add (Real x) (Real y)) (Add (Imaginary x) (Imaginary y)),
  Convert x = Complex (Convert x) Zero,
  Multiply x y =
    Complex
      (Minus (Multiply (Real x) (Real y)) (Multiply (Imaginary x) (Imaginary y)))
      (Add (Multiply (Real x) (Imaginary y)) (Multiply (Imaginary x) (Real y))),
  Negate x = Complex (Negate (Real x)) (Negate (Imaginary x)))
Instance Ring{Int}(Add = Add_Int, Convert = Id, Multiply = Multiply_Int, Negate = Negate_Int)
Instance Ring{Logical}(
  Add = Not_equal,
  Convert x = Equal (Mod_Int x 2) 1,
  Multiply x y = Match x {False -> False, True -> y},
  Negate = Id)
Instance Ring{Pair T U}<Ring T, Ring U>(
  Add x y = Pair (Add (First x) (First y)) (Add (Second x) (Second y)),
  Convert x = Pair (Convert x) (Convert x),
  Multiply x y = Pair (Multiply (First x) (First y)) (Multiply (Second x) (Second y)),
  Negate x = Pair (Negate (First x)) (Negate (Second x)))
Instance Ring{Polynomial T}<Ring T>(
  Add p q = Crash,
  Convert i = Polynomial (Lift (Convert i)),
  Multiply p q = Crash,
  Negate p = Polynomial (Map Negate (Coefficients p)))
Instance Ring{Trivial}(Add _ _ = Trivial, Convert _ = Trivial, Multiply _ _ = Trivial, Negate _ = Trivial)
Def Zero[T : Star]<Ring T> : T = Convert 0
Def Zip[F : Arrow Star Star, T : Star, U : Star, V : Star]<Applicative F>(f : Function T (Function U V), x : F T) :
  Function (F U) (F V) =
    Apply (Map f x)
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````