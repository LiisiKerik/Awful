`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Branching Array[!Nat][T : Star](!Zr -> Empty_Array, !Next N -> Construct_Array(Head : T, Tail : Array N T))
Struct Complex[T : Star](Real : T, Imaginary : T)
Struct Diagonal[N : !Nat, T : Star](Diagonal' : Array N T)
Algebraic Either[T : Star, U : Star](Left T, Right U)
Struct Fraction[T : Star](Numerator : T, Denominator : T)
Algebraic List[T : Star](Empty_List, Construct_List T (List T))
Algebraic Logical(False, True)
Struct Pair[T : Star, U : Star](First : T, Second : U)
Struct Polynomial[T : Star](Coefficients : List T)
`Constructor Polynomial[T : Star]<Commutative T, Ordered T>(Coefficients : List T) = Polynomial (Clean (Coefficients))
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz_triangle[N : !Nat, T : Star](Toeplitz_triangle' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
Struct Trivial
Class Antitail_help'{N : !Nat}(Antitail_help[T : Star] : Function T (Function (Array N T) (Array N T)))
Class Applicative{F : Arrow Star Star}<Functor>(
  Apply[T : Star, U : Star] : Function (F (Function T U)) (Function (F T) (F U)),
  Lift[T : Star] : Function T (F T))
Class Applicative_Array{N : !Nat}<Functor_Array>(
  Apply_Array[T : Star, U : Star] : Function (Array N (Function T U)) (Function (Array N T) (Array N U)),
  Lift_Array[T : Star] : Function T (Array N T))
Class Applicative_Square{N : !Nat}<Functor_Square>(
  Apply_Square[T : Star, U : Star] : Function (Square N (Function T U)) (Function (Square N T) (Square N U)),
  Lift_Square[T : Star] : Function T (Square N T))
Class Applicative_Triangle{N : !Nat}<Functor_Triangle>(
  Apply_Triangle[T : Star, U : Star] : Function (Triangle N (Function T U)) (Function (Triangle N T) (Triangle N U)),
  Lift_Triangle[T : Star] : Function T (Triangle N T))
Class Commutative{T : Star}<Ring>
Class Field{T : Star}<Ring>(Inverse : Function T (Maybe T))
Class Field_Array{N : !Nat}(Inverse_Array[T : Star]<Field T> : Function (Array N T) (Maybe (Array N T)))
Class Finite{T : Star}(All : List T)
Class Functor{F : Arrow Star Star}(Map[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))
Class Functor_Array{N : !Nat}(Map_Array[T : Star, U : Star] : Function (Function T U) (Function (Array N T) (Array N U)))
Class Functor_Square{N : !Nat}(Map_Square[T : Star, U : Star] : Function (Function T U) (Function (Square N T) (Square N U)))
Class Functor_Triangle{N : !Nat}(
  Map_Triangle[T : Star, U : Star] : Function (Function T U) (Function (Triangle N T) (Triangle N U)))
Class Foldable{F : Arrow Star Star}(
  Fold_right[T : Star, U : Star] : Function (Function T (Function U U)) (Function U (Function (F T) U)))
Class Matrix{F : Arrow !Nat (Arrow Star Star)}(
  Det[N : !Nat, T : Star]<Ring T> : Function (F N T) T,
  Fst[N : !Nat, T : Star] : Function (F (!Next N) T) T,
  Left_column[N : !Nat, T : Star]<Applicative_Array N, Ring T> : Function (F (!Next N) T) (Array N T),
  Matrix'[N : !Nat, T : Star] : Function (F (!Next N) T) (F N T),
  Top_row[N : !Nat, T : Star]<Applicative_Array N, Ring T> : Function (F (!Next N) T) (Array N T))
Class Matrix_product'{N : !Nat}(
  Matrix_by_vector[T : Star]<Ring T> : Function (Square N T) (Function (Array N T) (Array N T)),
  Matrix_product[T : Star]<Ring T> : Function (Array N T) (Function (Array N T) (Square N T)),
  Vector_by_matrix[T : Star]<Ring T> : Function (Array N T) (Function (Square N T) (Array N T)))
Class Monad{F : Arrow Star Star}<Applicative>(Bind[T : Star, U : Star] : Function (F T) (Function (Function T (F U)) (F U)))
Class Ordered{T : Star}(Compare : Function T (Function T Comparison))
Class Ring{T : Star}(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Multiply : Function T (Function T T),
  Negate : Function T T)
Class Ring_Square{N : !Nat}(
  Convert_Square[T : Star]<Ring T> : Function Int (Square N T),
  Multiply_Square[T : Star]<Ring T> : Function (Square N T) (Function (Square N T) (Square N T)))
Class Ring_Toeplitz_triangle{N : !Nat}(
  Convert_Toeplitz_triangle[T : Star]<Ring T> : Function Int (Array N T),
  Multiply_Toeplitz_triangle[T : Star]<Ring T> : Function (Array N T) (Function (Array N T) (Array N T)))
Class Writeable{T : Star}(Brackets : Function T (List Char), Write : Function T (List Char))
Def Add'[F : Arrow Star Star, T : Star]<Applicative F, Ring T> : Function (F T) (Function (F T) (F T)) = Zip Add
Def Add_Lists[T : Star]<Ring T>(l : List T, m : List T) : List T =
  Match l {
    Empty_List -> m,
    Construct_List x n -> Match m {Empty_List -> l, Construct_List y o -> Construct_List (Add x y) (Add_Lists n o)}}
Def Antitail[N : !Nat, T : Star]<Antitail_help' N>(a : Array (!Next N) T) : Array N T = Antitail_help (Head a) (Tail a)
Instance Antitail_help'{!Zr}(Antitail_help _ _ = Empty_Array)
Instance Antitail_help'{!Next N}<Antitail_help' N>(Antitail_help x a = Construct_Array x (Antitail a))
Instance Applicative{Array N}<Applicative_Array N>(Apply = Apply_Array, Lift = Lift_Array)
Instance Applicative{Complex}(Apply c d = Complex (Real c (Real d)) (Imaginary c (Imaginary d)), Lift x = Complex x x)
Instance Applicative{Diagonal N}<Applicative_Array N>(
  Apply d e = Diagonal (Apply (Diagonal' d) (Diagonal' e)),
  Lift x = Diagonal (Lift x))
Instance Applicative{Either _}(Apply d e = Match d {Left x -> Left x, Right f -> Map f e}, Lift = Right)
Instance Applicative{Function _}(Apply f g x = f x (g x), Lift x _ = x)
Instance Applicative{List}(
  Apply l m = Match l {Construct_List f n -> Concatenate (Map f m) (Apply n m), Empty_List -> Empty_List},
  Lift x = Construct_List x Empty_List)
Instance Applicative{Maybe}(Apply m n = Match m {Nothing -> Nothing, Wrap f -> Map f n}, Lift = Wrap)
Instance Applicative{Quaternion}(
  Apply q r = Quaternion (Qr q (Qr r)) (Qx q (Qx r)) (Qy q (Qy r)) (Qz q (Qz r)),
  Lift x = Quaternion x x x x)
Instance Applicative{Square N}<Applicative_Square N>(Apply = Apply_Square, Lift = Lift_Square)
Instance Applicative{Toeplitz_triangle N}<Applicative_Array N>(
  Apply d e = Toeplitz_triangle (Apply (Toeplitz_triangle' d) (Toeplitz_triangle' e)),
  Lift x = Toeplitz_triangle (Lift x))
Instance Applicative{Triangle N}<Applicative_Triangle N>(Apply = Apply_Triangle, Lift = Lift_Triangle)
Instance Applicative_Array{!Zr}(Apply_Array _ _ = Empty_Array, Lift_Array _ = Empty_Array)
Instance Applicative_Array{!Next N}<Applicative_Array N>(
  Apply_Array a b = Construct_Array (Head a (Head b)) (Apply (Tail a) (Tail b)),
  Lift_Array x = Construct_Array x (Lift x))
Instance Applicative_Square{!Zr}(Apply_Square _ _ = Empty_Square, Lift_Square _ = Empty_Square)
Instance Applicative_Square{!Next N}<Applicative_Array N, Applicative_Square N>(
  Apply_Square x y =
    Construct_Square
      (Fst x (Fst y))
      (Apply (Top_row_Square x) (Top_row_Square y))
      (Apply (Left_column_Square x) (Left_column_Square y))
      (Apply (Matrix' x) (Matrix' y)),
  Lift_Square x = Construct_Square x (Lift x) (Lift x) (Lift x))
Instance Applicative_Triangle{!Zr}(Apply_Triangle _ _ = Empty_Triangle, Lift_Triangle _ = Empty_Triangle)
Instance Applicative_Triangle{!Next N}<Applicative_Array N, Applicative_Triangle N>(
  Apply_Triangle x y =
    Construct_Triangle
      (Fst x (Fst y))
      (Apply (Top_row_Triangle x) (Top_row_Triangle y))
      (Apply (Matrix' x) (Matrix' y)),
  Lift_Triangle x = Construct_Triangle x (Lift x) (Lift x))
Def Brackets'[T : Star]<Writeable T>(x : T) : List Char = Construct_List "(" (Concatenate (Write x) (Lift ")"))
Def Clean[T : Star]<Ordered T, Ring T>(c : List T) : List T =
  Match c {
    Empty_List -> Empty_List,
    Construct_List x c' ->
      Match Clean c' {Empty_List -> Match Equal x Zero {False -> Empty_List, True -> Lift x}, Construct_List _ _ -> c}}
Instance Commutative{Array N T}<Applicative_Array N, Commutative T>
Instance Commutative{Complex T}<Commutative T>
Instance Commutative{Diagonal N T}<Applicative_Array N, Commutative T>
Instance Commutative{Fraction T}<Commutative T>
Instance Commutative{Int}
Instance Commutative{Logical}
Instance Commutative{Pair T U}<Commutative T, Commutative U>
Instance Commutative{Polynomial T}<Commutative T, Ordered T>
Instance Commutative{Toeplitz_triangle N T}<Applicative_Array N, Commutative T, Ring_Toeplitz_triangle N>
Instance Commutative{Trivial}
Def Compare'[T : Star, U : Star]<Ordered T, Ordered U>(x : T, y : T, a : U, b : U) : Comparison =
  Match Compare x y {LT -> LT, EQ -> Compare a b, GT -> GT}
Def Concatenate[T : Star](l : List T, m : List T) : List T = Match l {
  Construct_List x n -> Construct_List x (Concatenate n m),
  Empty_List -> m}
Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T = Multiply (Inverse x) (Wrap y)`Map (z -> Multiply z y) (Inverse x)
Def Div_right[T : Star]<Field T>(x : T, y : T) : Maybe T = Map (Multiply x) (Inverse y)
Def Dot_product[N : !Nat, T : Star]<Applicative_Array N, Ring T>(x : Array N T, y : Array N T) : T = Sum (Multiply x y)
Def Equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> True, Default -> False}
~/
Struct Complex[T : Star](Real : T, Imaginary : T)
Struct Diagonal[N : !Nat, T : Star](Diagonal' : Array N T)
Algebraic Either[T : Star, U : Star](Left T, Right U)
Struct Fraction[T : Star](Numerator : T, Denominator : T)
Algebraic List[T : Star](Empty_List, Construct_List T (List T))
Algebraic Logical(False, True)
Struct Pair[T : Star, U : Star](First : T, Second : U)
Struct Polynomial[T : Star](Coefficients : List T)
`Constructor Polynomial[T : Star]<Commutative T, Ordered T>(Coefficients : List T) = Polynomial (Clean (Coefficients))
Struct Quaternion[T : Star](Qr : T, Qx : T, Qy : T, Qz : T)
Branching Square[!Nat][T : Star](
  !Zr -> Empty_Square,
  !Next N ->
    Construct_Square(Fst_Square : T, Top_row_Square : Array N T, Left_column_Square : Array N T, Square' : Square N T))
Struct Toeplitz_triangle[N : !Nat, T : Star](Toeplitz_triangle' : Array N T)
Branching Triangle[!Nat][T : Star](
  !Zr -> Empty_Triangle,
  !Next N -> Construct_Triangle(Fst_Triangle : T, Top_row_Triangle : Array N T, Triangle' : Triangle N T))
/~
Instance Field{Array N T}<Applicative_Array N, Field_Array N, Field T>(Inverse = Inverse_Array)
Instance Field{Complex T}<Commutative T, Field T>(Inverse x = Crash)
Instance Field{Int}(Inverse x = Match x {-1 -> Wrap -1, 1 -> Wrap 1, Default -> Nothing})
Instance Field{Logical}(Inverse x = Match x {False -> Nothing, True -> Wrap x})
Instance Field{Pair T U}<Field T, Field U>(
  Inverse x =
    Match Inverse (First x) {
      Nothing -> Nothing,
      Wrap y -> Match Inverse (Second x) {Nothing -> Nothing, Wrap z -> Wrap (Pair y z)}})
Instance Field{Trivial}(Inverse = Wrap)
Instance Field_Array{!Zr}(Inverse_Array = Wrap)
Instance Field_Array{!Next N}<Applicative_Array N, Field_Array N>(
  Inverse_Array x = Zip Construct_Array (Inverse (Head x)) (Inverse (Tail x)))
Def Filter_List[T : Star](f : Function T Logical, x : List T) : List T = Match x {
  Construct_List y z -> (w -> Match f y {
    False -> w,
    True -> Construct_List y w}) (Filter_List f z),
  Empty_List -> Empty_List}
Instance Finite{Array N T}<Finite T>(All = Crash)
Instance Finite{Comparison}(All = Construct_List LT (Construct_List EQ (Construct_List GT Empty_List)))
Instance Finite{Complex T}<Finite T>(All = Zip Complex All All)
Instance Finite{Diagonal _ T}<Finite T>(All = Map Diagonal All)
Instance Finite{Either T U}<Finite T, Finite U>(All = Concatenate (Map Left All) (Map Right All))
Instance Finite{Fraction T}<Commutative T, Finite T>(All = Crash)
Instance Finite{Logical}(All = Construct_List False (Construct_List True Empty_List))
Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Pair All All)
Instance Finite{Polynomial T}<Commutative T, Finite T, Ordered T>(All = Crash)
Instance Finite{Quaternion T}<Finite T>(All = Apply (Apply (Apply (Map Quaternion All) All) All) All)
Instance Finite{Square N T}<Finite T>(All = Crash)
Instance Finite{Toeplitz_triangle _ T}<Finite T>(All = Map Toeplitz_triangle All)
Instance Finite{Triangle N T}<Finite T>(All = Crash)
Instance Finite{Trivial}(All = Construct_List Trivial Empty_List)
Def Flatten[F : Arrow Star Star, T : Star]<Monad F>(x : F (F T)) : F T = Bind x Id
Instance Foldable{Array N}(Fold_right = Crash)
Instance Functor{Array N}<Functor_Array N>(Map = Map_Array)
Instance Functor{Complex}(Map f c = Complex (f (Real c)) (f (Imaginary c)))
Instance Functor{Diagonal N}<Functor_Array N>(Map f d = Diagonal (Map f (Diagonal' d)))
Instance Functor{Either _}(Map f x = Match x {Left y -> Left y, Right y -> Right (f y)})
Instance Functor{Function _}(Map f g x = f (g x))
Instance Functor{List}(Map f l = Match l {Empty_List -> Empty_List, Construct_List x m -> Construct_List (f x) (Map f m)})
Instance Functor{Maybe}(Map f m = Match m {Nothing -> Nothing, Wrap x -> Wrap (f x)})
Instance Functor{Pair _}(Map f x = Pair (First x) (f (Second x)))
Instance Functor{Quaternion}(Map f q = Quaternion (f (Qr q)) (f (Qx q)) (f (Qy q)) (f (Qz q)))
Instance Functor{Square N}<Functor_Square N>(Map = Map_Square)
Instance Functor{Toeplitz_triangle N}<Functor_Array N>(Map f t = Toeplitz_triangle (Map f (Toeplitz_triangle' t)))
Instance Functor{Triangle N}<Functor_Triangle N>(Map = Map_Triangle)
Instance Functor_Array{!Zr}(Map_Array _ _ = Empty_Array)
Instance Functor_Array{!Next N}<Functor_Array N>(Map_Array f a = Construct_Array (f (Head a)) (Map f (Tail a)))
Instance Functor_Square{!Zr}(Map_Square _ _ = Empty_Square)
Instance Functor_Square{!Next N}<Functor_Array N, Functor_Square N>(
  Map_Square f s =
    Construct_Square (f (Fst s)) (Map f (Top_row_Square s)) (Map f (Left_column_Square s)) (Map f (Matrix' s)))
Instance Functor_Triangle{!Zr}(Map_Triangle _ _ = Empty_Triangle)
Instance Functor_Triangle{!Next N}<Functor_Array N, Functor_Triangle N>(
  Map_Triangle f t = Construct_Triangle (f (Fst t)) (Map f (Top_row_Triangle t)) (Map f (Matrix' t)))
Def Greater[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {GT -> True, Default -> False}
Def Greater_or_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {LT -> False, Default -> True}
Def Id[T : Star](x : T) : T = x
Def Identity[T : Star]<Ring T> : T = Convert 0
Def Less[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {LT -> True, Default -> False}
Def Less_or_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {GT -> False, Default -> True}
Def Map_Polynomial[T : Star, U : Star]<Commutative T, Commutative U, Ordered T, Ordered U>
  (f : Function T U, x : Polynomial T) : Polynomial U =
    Polynomial (Map f (Coefficients x))
Instance Matrix{Diagonal}(
  Det d = Crash,
  Fst d = Head (Diagonal' d),
  Left_column _ = Zero,
  Matrix' d = Diagonal (Tail (Diagonal' d)),
  Top_row _ = Zero)
Instance Matrix{Square}(
  Det d = Crash,
  Fst = Fst_Square,
  Left_column = Left_column_Square,
  Matrix' = Square',
  Top_row = Top_row_Square)
Instance Matrix{Triangle}(
  Det d = Crash,
  Fst = Fst_Triangle,
  Left_column _ = Zero,
  Matrix' = Triangle',
  Top_row = Top_row_Triangle)
Instance Matrix_product'{!Zr}(
  Matrix_by_vector _ _ = Empty_Array,
  Matrix_product _ _ = Empty_Square,
  Vector_by_matrix _ _ = Empty_Array)
Instance Matrix_product'{!Next N}<Applicative_Array N, Matrix_product' N>(
  Matrix_by_vector x y =
    Construct_Array
      (Dot_product (Construct_Array (Fst x) (Top_row x)) y)
      (Add (Multiply_right (Left_column x) (Head y)) (Matrix_by_vector (Matrix' x) (Tail y))),
  Matrix_product x y =
    Construct_Square
      (Multiply (Head x) (Head y))
      (Multiply_left (Head x) (Tail y))
      (Multiply_right (Tail x) (Head y))
      (Matrix_product (Tail x) (Tail y)),
  Vector_by_matrix x y =
    Construct_Array
      (Dot_product x (Construct_Array (Fst y) (Left_column y)))
      (Add (Multiply_left (Head x) (Top_row y)) (Vector_by_matrix (Tail x) (Matrix' y))))
Def Minus[T : Star]<Ring T>(x : T, y : T) : T = Add x (Negate y)
Instance Monad{List}(Bind l f = Match l {Empty_List -> Empty_List, Construct_List x m -> Concatenate (f x) (Bind m f)})
Def Multiply_Lists[T : Star]<Commutative T>(x : List T, y : List T) : List T =
  Match x {
    Empty_List -> Empty_List,
    Construct_List a b ->
      Match y {
        Empty_List -> Empty_List,
        Construct_List c d ->
          Construct_List
            (Multiply a c)
            (Add_Lists (Add_Lists (Multiply_left a d) (Multiply_right b c)) (Multiply_Lists b d))}}
Def Multiply_left[T : Star, F : Arrow Star Star]<Functor F, Ring T>(x : T, y : F T) : F T = Map (Multiply x) y
Def Multiply_right[F : Arrow Star Star, T : Star]<Functor F, Ring T>(x : F T, y : T) : F T = Map (z -> Multiply z y) x
Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}
Def Negate'[F : Arrow Star Star, T : Star]<Functor F, Ring T> : Function (F T) (F T) = Map Negate
Def Not_equal[T : Star]<Ordered T>(x : T, y : T) : Logical = Match Compare x y {EQ -> False, Default -> True}
Instance Ordered{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, Default -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, Default -> GT}})
Instance Ordered{Complex T}<Ordered T>(Compare x y = Compare' (Real x) (Real y) (Imaginary x) (Imaginary y))
Instance Ordered{Either T U}<Ordered T, Ordered U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right -> LT},
      Right z -> Match y {Left -> GT, Right w -> Compare z w}})
Instance Ordered{Function T U}<Finite T, Ordered U>(Compare f g = Compare (Map f All) (Map g All))
Instance Ordered{Int}(Compare = Compare_Int)
Instance Ordered{List T}<Ordered T>(
  Compare x y =
    Match x {
      Construct_List z w ->
        Match y {Construct_List a b -> (c -> Match c {EQ -> Compare w b, Default -> c}) (Compare z a), Empty_List -> GT},
      Empty_List -> Match y {Construct_List -> LT, Empty_List -> EQ}})
Instance Ordered{Logical}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Instance Ordered{Maybe T}<Ordered T>(
  Compare x y =
    Match x {Nothing -> Match y {Nothing -> EQ, Wrap -> LT}, Wrap z -> Match y {Nothing -> GT, Wrap w -> Compare z w}})
Instance Ordered{Pair T U}<Ordered T, Ordered U>(Compare x y = Compare' (First x) (First y) (Second x) (Second y))
Instance Ordered{Trivial}(Compare _ _ = EQ)
Instance Ring{Array N T}<Applicative_Array N, Ring T>(
  Add = Add',
  Convert x = Lift (Convert x),
  Multiply = Zip Multiply,
  Negate = Negate')
Instance Ring{Complex T}<Ring T>(
  Add = Add',
  Convert x = Complex (Convert x) Zero,
  Multiply x y =
    Complex
      (Minus (Multiply (Real x) (Real y)) (Multiply (Imaginary x) (Imaginary y)))
      (Add (Multiply (Real x) (Imaginary y)) (Multiply (Imaginary x) (Real y))),
  Negate = Negate')
Instance Ring{Diagonal N T}<Applicative_Array N, Ring T>(
  Add = Add',
  Convert x = Lift (Convert x),
  Multiply d e = Diagonal (Multiply (Diagonal' d) (Diagonal' e)),
  Negate = Negate')
Instance Ring{Fraction T}<Commutative T>(
  Add x y =
    Fraction
      (Add (Multiply (Numerator x) (Denominator y)) (Multiply (Denominator x) (Numerator y)))
      (Multiply (Denominator x) (Denominator y)),
  Convert x = Fraction (Convert x) Identity,
  Multiply x y = Fraction (Multiply (Numerator x) (Numerator y)) (Multiply (Denominator x) (Denominator y)),
  Negate x = Fraction (Negate (Numerator x)) (Denominator x))
Instance Ring{Int}(Add = Add_Int, Convert = Id, Multiply = Multiply_Int, Negate = Negate_Int)
Instance Ring{Logical}(
  Add = Not_equal,
  Convert x = Equal (Mod_Int x 2) 1,
  Multiply x y = Match x {False -> False, True -> y},
  Negate = Id)
Instance Ring{Maybe T}<Ring T>(Add = Add', Convert x = Wrap (Convert x), Multiply = Zip Multiply, Negate = Negate')
Instance Ring{Pair T U}<Ring T, Ring U>(
  Add x y = Pair (Add (First x) (First y)) (Add (Second x) (Second y)),
  Convert x = Pair (Convert x) (Convert x),
  Multiply x y = Pair (Multiply (First x) (First y)) (Multiply (Second x) (Second y)),
  Negate x = Pair (Negate (First x)) (Negate (Second x)))
Instance Ring{Polynomial T}<Commutative T, Ordered T>(
  Add p q = Polynomial (Multiply_Lists (Coefficients p) (Coefficients q)),
  Convert i = Polynomial (Lift (Convert i)),
  Multiply p q = Polynomial (Add_Lists (Coefficients p) (Coefficients q)),
  Negate = Map_Polynomial Negate)
Instance Ring{Quaternion T}<Ring T>(
  Add = Add',
  Convert x = Quaternion (Convert x) Zero Zero Zero,
  Multiply q r =
    Quaternion
      (Minus
        (Minus (Minus (Multiply (Qr q) (Qr r)) (Multiply (Qx q) (Qx r))) (Multiply (Qy q) (Qy r)))
        (Multiply (Qz q) (Qz r)))
      (Add
        (Minus (Add (Multiply (Qr q) (Qx r)) (Multiply (Qx q) (Qr r))) (Multiply (Qy q) (Qz r)))
        (Multiply (Qz q) (Qy r)))
      (Minus
        (Add (Add (Multiply (Qr q) (Qy r)) (Multiply (Qx q) (Qz r))) (Multiply (Qy q) (Qr r)))
        (Multiply (Qz q) (Qx r)))
      (Add
        (Add (Minus (Multiply (Qr q) (Qz r)) (Multiply (Qx q) (Qy r))) (Multiply (Qy q) (Qx r)))
        (Multiply (Qz q) (Qr r))),
  Negate = Negate')
Instance Ring{Square N T}<Applicative_Square N, Ring T, Ring_Square N>(
  Add = Add',
  Convert = Convert_Square,
  Multiply = Multiply_Square,
  Negate = Negate')
Instance Ring{Toeplitz_triangle N T}<Applicative_Array N, Ring T, Ring_Toeplitz_triangle N>(
  Add = Add',
  Convert i = Toeplitz_triangle (Convert_Toeplitz_triangle i),
  Multiply x y = Toeplitz_triangle (Multiply_Toeplitz_triangle (Toeplitz_triangle' x) (Toeplitz_triangle' y)),
  Negate = Negate')
Instance Ring{Trivial}(Add _ _ = Trivial, Convert _ = Trivial, Multiply _ _ = Trivial, Negate _ = Trivial)
Instance Ring_Square{!Zr}(Convert_Square _ = Empty_Square, Multiply_Square _ _ = Empty_Square)
Instance Ring_Square{!Next N}<Applicative_Array N, Applicative_Square N, Matrix_product' N, Ring_Square N>(
  Convert_Square i = Construct_Square (Convert i) Zero Zero (Convert i),
  Multiply_Square x y =
    Construct_Square
      (Add (Multiply (Fst x) (Fst y)) (Dot_product (Top_row x) (Left_column y)))
      (Add (Multiply_left (Fst x) (Top_row y)) (Vector_by_matrix (Top_row x) (Matrix' y)))
      (Add (Multiply_right (Left_column x) (Fst y)) (Matrix_by_vector (Matrix' x) (Left_column y)))
      (Add (Matrix_product (Left_column x) (Top_row x)) (Multiply (Matrix' x) (Matrix' y))))
Instance Ring_Toeplitz_triangle{!Zr}(
  Convert_Toeplitz_triangle _ = Empty_Array,
  Multiply_Toeplitz_triangle _ _ = Empty_Array)
Instance Ring_Toeplitz_triangle{!Next N}<Antitail_help' N, Applicative_Array N, Ring_Toeplitz_triangle N>(
  Convert_Toeplitz_triangle i = Construct_Array (Convert i) Zero,
  Multiply_Toeplitz_triangle x y =
    Construct_Array
      (Multiply (Head x) (Head y))
      (Add (Multiply_left (Head x) (Tail y)) (Multiply_Toeplitz_triangle (Tail x) (Antitail y))))
Def Sum[F : Arrow Star Star, T : Star]<Foldable F, Ring T> : Function (F T) T = Fold_right Add Zero
Def Zero[T : Star]<Ring T> : T = Convert 0
Def Zip[F : Arrow Star Star, T : Star, U : Star, V : Star]<Applicative F>(f : Function T (Function U V), x : F T) :
  Function (F U) (F V) =
    Apply (Map f x)
Def Write'(l : List (List Char)) : List Char =
  Match l {Empty_List -> Empty_List, Construct_List m n -> Concatenate m (Flatten (Map (Construct_List " ") n))}
Instance Writeable{Complex T}<Writeable T>(
  Brackets = Brackets',
  Write c = Construct_List " " (Concatenate (Brackets (Real c)) (Construct_List " " (Brackets (Imaginary c)))))
Instance Writeable{Logical}(
  Brackets = Write,
  Write x =
    Match x {
      False ->
        Construct_List "F" (Construct_List "a" (Construct_List "l" (Construct_List "s" (Construct_List "e" Empty_List)))),
      True -> Construct_List "T" (Construct_List "r" (Construct_List "u" (Construct_List "e" Empty_List)))})
Instance Writeable{Trivial}(
  Brackets = Write,
  Write _ =
    Construct_List
      "T"
      (Construct_List
        "r"
        (Construct_List "i" (Construct_List "v" (Construct_List "i" (Construct_List "a" (Construct_List "l" Empty_List)))))))
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````