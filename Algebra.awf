`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
`Struct Array[N : Nat, T : Star](Index : Function (Finite N) T)
Struct Complex[T : Star](Real : T, Imaginary : T)
Algebraic Either[T : Star, U : Star](Left T, Right U)
Struct Fraction[T : Star](Numerator : T, Denominator : T)
Algebraic List[T : Star](Construct T (List T), Empty_List)
Algebraic Logical(False, True)
Algebraic Maybe[T : Star](Nothing, Wrap T)
Struct Pair[T : Star, U : Star](First : T, Second : U)
Struct Polynomial[T : Star](Coefficients : List T)
Struct Quaternion[T : Star](Qa : T, Qx : T, Qy : T, Qz : T)
Struct Trivial
Class Finite(T : Star)(All : List T)
`Class Functor(F : Arrow Star Star)(Map[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))
Class Ring(T : Star)(
  Add : Function T (Function T T),
  Convert : Function Int T,
  Inverse : Function T (Maybe T),
  Multiply : Function T (Function T T),
  Negate : Function T T)
`Abstract Apply{F : Arrow Star Star}[T : Star, U : Star] : F (T -> U) -> F T -> F U
`Abstract Det{F : Arrow Star Star}[T : Star] : F T -> T
`Abstract Fold{F : Arrow Star Star}[T : Star, U : Star] : (T -> U -> U) -> U -> F T -> U
`Abstract Top_row{F : # -> * -> *}[N : #, T : Star] : F N T -> Array (N - 1) T
`Instance Add{Array _ T}<Add T> = Map Apply (Map Add)
Def Add_Complex[T : Star](Add_T : Function T (Function T T)) : Function (Complex T) (Function (Complex T) (Complex T)) =
  Add_Functor Add_T Apply_Complex Apply_Complex Lift_Complex
Def Add_Logical : Function Logical (Function Logical Logical) = Not_Equal Compare_Logical
`Instance Add{Pair T U}<Add T, Add U> = Zip_Pair Add Add
Def Add_Pair[A : Star, B : Star] :
  Function
    (Function A (Function A A))
    (Function (Function B (Function B B)) (Function (Pair A B) (Function (Pair A B) (Pair A B)))) =
      Zip_Pair
`Instance Add{Maybe T}<Add T> = Add_Functor
Def Add_Maybe[T : Star](Add_T : Function T (Function T T)) : Function (Maybe T) (Function (Maybe T) (Maybe T)) =
  Add_Functor Add_T Apply_Maybe Apply_Maybe Lift_Maybe
`Instance Add{Trivial} = Trivial_binary
Def Add_Trivial : Function Trivial (Function Trivial Trivial) = Trivial_binary
`Instance Add{F T}<Add T, Apply F, Lift F> = Zip Add
Def Add_Functor[T : Star, F : Arrow Star Star]
  (
    Add_T : Function T (Function T T),
    Apply_F' : Function (F (Function T (Function T T))) (Function (F T) (F (Function T T))),
    Apply_F'' : Function (F (Function T T)) (Function (F T) (F T)),
    Lift_F : Function (Function T (Function T T)) (F (Function T (Function T T)))) :
      Function (F T) (Function (F T) (F T)) =
        Zip Apply_F' Apply_F'' Lift_F Add_T
`Instance Add{Logical} = Not_Equal
~/
Instance Apply{Array _} x y = Array (Apply (Array_function x) (Array_function y))
Def Apply_Array[N : #, T : Star, U : Star](x : Array N (T -> U), y : Array N T) : Array N U =
  Array (Apply_Function (Array_function x) (Array_function y))
Def Apply_Array[A : Star, B : Star](x : Array (Function A B), y : Array A) : Maybe (Array B) =
  Match Equal_Int (Length x) (Length y) {
    False -> Nothing,
    True -> Array (Length x) (z -> (Unsafe_Index x z) (Unsafe_Index y z))}
/~
`Instance Apply{Complex} x y = Complex (Real x (Real y)) (Imaginary x (Imaginary y))
Def Apply_Complex[T : Star, U : Star](x : Complex (Function T U), y : Complex T) : Complex U =
  Complex (Real x (Real y)) (Imaginary x (Imaginary y))
Def Apply_Either[A : Star, B : Star, C : Star](x : Either A (Function B C), y : Either A B) : Either A C = Match x {
  Left z -> Left z,
  Right f -> Map_Either f y}
`Instance Apply{Function _} f g x = f x (g x)
Def Apply_Function[A : Star, B : Star, C : Star](f : Function A (Function B C), g : Function A B, x : A) : C = f x (g x)
Def Apply_List[T : Star, U : Star](x : List (Function T U), y : List T) : List U = Match x {
  Construct f z -> Join_List (Map_List f y) (Apply_List z y),
  Empty_List -> Empty_List}
Def Apply_Maybe[A : Star, B : Star](x : Maybe (Function A B), y : Maybe A) : Maybe B = Match x {
  Nothing -> Nothing,
  Wrap f -> Map_Maybe f y}
Def Bimap[T : Star, U : Star, V : Star, W : Star](f : Function T U, g : Function V W, x : Pair T V) : Pair U W =
  Pair (f (First x)) (g (Second x))
Def Clean[T : Star](Equal_T : Function T (Function T Logical), x : List T) : List T = Match x {
  Construct y z -> (w -> (a -> Match Equal_T y Crash {
    False -> a,
    True -> Match w {
      Construct -> a,
      Empty_List -> Empty_List}}) (Construct y w)) (Clean Equal_T z),
  Empty_List -> Empty_List}
Def Compare_Comparison(x : Comparison, y : Comparison) : Comparison = Match x {
  LT -> Match y {
    LT -> EQ,
    Default -> LT},
  EQ -> Match y {
    LT -> GT,
    EQ -> EQ,
    GT -> LT},
  GT -> Match y {
    GT -> EQ,
    Default -> GT}}
Def Compare_Complex[T : Star](Compare_T : Function T (Function T Comparison), x : Complex T, y : Complex T) : Comparison =
  Match Compare_T (Real x) (Real y) {
    LT -> LT,
    EQ -> Compare_T (Imaginary x) (Imaginary y),
    GT -> GT}
Def Compare_Either[T : Star, U : Star]
  (
    Compare_T : Function T (Function T Comparison),
    Compare_U : Function U (Function U Comparison),
    x : Either T U,
    y : Either T U) :
      Comparison =
        Match x {
          Left z -> Match y {
            Left w -> Compare_T z w,
            Right -> LT},
          Right z -> Match y {
            Left -> GT,
            Right w -> Compare_U z w}}
Def Compare_Function[T : Star, U : Star]
  (All_T : List T, Compare_U : Function U (Function U Comparison), f : Function T U, g : Function T U) : Comparison =
    Compare_List Compare_U (Map_List f All_T) (Map_List g All_T)
Def Compare_List[T : Star](Compare_T : Function T (Function T Comparison), x : List T, y : List T) : Comparison = Match x {
  Construct z w -> Match y {
    Construct a b -> (c -> Match c {
      EQ -> Compare_List Compare_T w b,
      Default -> c}) (Compare_T z a),
    Empty_List -> GT},
  Empty_List -> Match y {
    Construct -> LT,
    Empty_List -> EQ}}
Def Compare_Logical(x : Logical, y : Logical) : Comparison = Match x {
  False -> Match y {
    False -> EQ,
    True -> LT},
  True -> Match y {
    False -> GT,
    True -> EQ}}
Def Compare_Maybe[T : Star](Compare_T : Function T (Function T Comparison), x : Maybe T, y : Maybe T) : Comparison =
  Match x {
    Nothing -> Match y {
      Nothing -> EQ,
      Wrap -> LT},
    Wrap z -> Match y {
      Nothing -> GT,
      Wrap w -> Compare_T z w}}
Def Compare_Pair[T : Star, U : Star]
  (
    Compare_T : Function T (Function T Comparison),
    Compare_U : Function U (Function U Comparison),
    x : Pair T U,
    y : Pair T U) :
      Comparison =
        Match Compare_T (First x) (First y) {
          EQ -> Compare_U (Second x) (Second y),
          GT -> GT,
          LT -> LT}
Def Compare_Trivial(_ : Trivial, _ : Trivial) : Comparison = EQ
Def Convert_Complex[T : Star](Convert_T : Function Int T, x : Int) : Complex T = Complex (Convert_T x) (Zero Convert_T)
`Instance Convert{Int} = Id
Def Convert_Int : Function Int Int = Id
`Instance Convert{Logical} x = Equal (Mod x 2) 1
Def Convert_Logical(x : Int) : Logical = Equal Compare_Int (Mod_Int x 2) 1
Def Convert_Polynomial[T : Star]
  (Convert_T : Function Int T, Equal_T : Function T (Function T Logical), x : Int) : Polynomial T =
    Polynomial (Clean Equal_T (Lift_List (Convert_T x)))
`Instance Convert{Trivial} _ = Trivial
Def Convert_Trivial(_ : Int) : Trivial = Trivial
Def Det_Complex[T : Star](Add_T : Function T (Function T T), Multiply_T : Function T (Function T T), x : Complex T) : T =
  Add_T (Crash (Real x)) (Crash (Imaginary x))
Def Equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  EQ -> True,
  Default -> False}
Def Filter_List[T : Star](f : Function T Logical, x : List T) : List T = Match x {
  Construct y z -> (w -> Match f y {
    False -> w,
    True -> Construct y w}) (Filter_List f z),
  Empty_List -> Empty_List}
Def Filter_Maybe[T : Star](f : Function T Logical, x : Maybe T) : Maybe T = Match x {
  Nothing -> Nothing,
  Wrap y -> Match f y {
    False -> Nothing,
    True -> x}}
Instance Finite(Comparison)(All = Construct LT (Construct EQ (Construct GT Empty_List)))
`Def All_Complex[T : Star](All_T : List T) : List (Complex T) = Zip Apply_List Apply_List Lift_List Complex All_T All_T
~/
Def All_Either[T : Star, U : Star](All_T : List T, All_U : List U) : List (Either T U) =
  Join_List (Map_List Left All_T) (Map_List Right All_U)
/~
`Def All_Function[T : Star, U : Star](All_T : List T, All_U : List U) : List (Function T U) = Crash
Instance Finite(Logical)(All = Construct False (Construct True Empty_List))
`Instance All{Pair T U}<All T, All U> = Zip Pair All All
~/
Def All_Pair[T : Star, U : Star](All_T : List T, All_U : List U) : List (Pair T U) =
  Zip Apply_List Apply_List Lift_List Pair All_T All_U
/~
Instance Finite(Trivial)(All = Construct Trivial Empty_List)
Def Flatten_Either[T : Star, U : Star](x : Either T (Either T U)) : Either T U = Match x {
  Left y -> Left y,
  Right y -> y}
Def Flatten_Function[T : Star, U : Star](f : Function T (Function T U), x : T) : U = f x x
Def Flatten_List[T : Star](x : List (List T)) : List T = Match x {
  Construct y z -> Join_List y (Flatten_List z),
  Empty_List -> Empty_List}
Def Flatten_Maybe[T : Star](x : Maybe (Maybe T)) : Maybe T = Match x {
  Nothing -> Nothing,
  Wrap y -> y}
Def Flip[A : Star, B : Star, C : Star](f : Function A (Function B C), x : B, y : A) : C = f y x
`Instance Fold{Complex} f x y = Crash
Def Fold_Left[T : Star, U : Star](f : Function T (Function U T), x : T, y : List U) : T = Match y {
  Construct z w -> Fold_Left f (f x z) w,
  Empty_List -> x}
Def Fold_Right[T : Star, U : Star](f : Function T (Function U U), x : U, y : List T) : U = Match y {
  Construct z w -> f z (Fold_Right f x y),
  Empty_List -> x}
Def Greater[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  GT -> True,
  Default -> False}
Def Greater_or_equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical =
  Match Compare_T x y {
    LT -> False,
    Default -> True}
Def Id[A : Star](x : A) : A = x
`Def Identity[T : Star]<Convert T> : T = Convert 0
Def Identity[A : Star](Convert_A : Function Int A) : A = Convert_A 1
`Instance Inverse{Trivial} = Wrap
Def Inverse_Trivial : Function Trivial (Maybe Trivial) = Wrap
Def Inverse_Int(x : Int) : Maybe Int = Match x {
  -1 -> Wrap -1,
  1 -> Wrap 1,
  Default -> Nothing}
~/
Def Join_Array[A : Star](x : Array A, y : Array A) : Array A =
  Unsafe_Array (Add_Int (Length x) (Length y)) (z -> Match Less_Int z (Length x) {
    False -> Unsafe_Index y (Minus Add_Int Negate_Int z (Length x)),
    True -> Unsafe_Index x z})
/~
Def Join_List[T : Star](x : List T, y : List T) : List T = Match x {
  Construct z w -> Construct z (Join_List w y),
  Empty_List -> y}
~/
Def Lead_Complex[T : Star] : Function (Complex T) T = Real
Def Lead_Quaternion[T : Star] : Function (Quaternion T) T = Qx
Def Less[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  LT -> True,
  Default -> False}
Def Less_or_equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  GT -> False,
  Default -> True}
Instance Lift{Array _} = Map Array Lift
Def Lift_Array[N : #, T : Star] : T -> Array N T = Map_Function Array Lift_Function
Def Lift_Array[A : Star](x : Int, y : A) : Maybe (Array A) = Array x (Lift_Function y)
/~
`Instance Lift{Complex} x = Complex x x
Def Lift_Complex[T : Star](x : T) : Complex T = Complex x x
`Instance Lift{Either _} = Right
Def Lift_Either[A : Star, B : Star] : Function B (Either A B) = Right
`Instance Lift{Function _} x _ = x
Def Lift_Function[A : Star, B : Star](x : A, _ : B) : A = x
Def Lift_List[T : Star](x : T) : List T = Construct x Empty_List
`Instance Lift{Maybe} = Wrap
Def Lift_Maybe[T : Star] : Function T (Maybe T) = Wrap
~/
Instance Map{Array _} x y = Array (Map x (Array_function y))
Def Map_Array[T : Star, U : Star, N : #](x : T -> U, y : Array N T) : Array N U = Array (Map_Function x (Array_function y))
Def Map_Array[A : Star, B : Star](f : Function A B, x : Array A) : Array B =
  Unsafe_Array (Length x) (y -> f (Unsafe_Index x y))
/~
`Instance Map{Complex} = Map_Functor
Def Map_Complex[T : Star, U : Star] : Function (Function T U) (Function (Complex T) (Complex U)) =
  Map_Function Apply_Complex Lift_Complex
Def Map_Either[A : Star, B : Star, C : Star](f : Function A B, x : Either C A) : Either C B = Match x {
  Left y -> Left y,
  Right y -> Right (f y)}
`Instance Map{Function _} f g x = f (g x)
Def Map_Function[A : Star, B : Star, C : Star](f : Function A B, g : Function C A, x : C) : B = f (g x)
Def Map_Functor[F : Arrow Star Star, T : Star, U : Star]
  (
    Apply_T : Function (F (Function T U)) (Function (F T) (F U)),
    Lift_T : Function (Function T U) (F (Function T U)),
    f : Function T U) :
      Function (F T) (F U) =
        Apply_T (Lift_T f)
Def Map_List[T : Star, U : Star](f : Function T U, x : List T) : List U = Match x {
  Construct y z -> Construct (f y) (Map_List f z),
  Empty_List -> Empty_List}
Def Map_Maybe[A : Star, B : Star](f : Function A B, x : Maybe A) : Maybe B = Match x {
  Nothing -> Nothing,
  Wrap y -> Wrap (f y)}
`Instance Map{Pair _} f x = Pair (First x) (f (Second x))
Def Map_Pair[A : Star, B : Star, C : Star](f : Function A B, x : Pair C A) : Pair C B = Pair (First x) (f (Second x))
Def Map_Polynomial[T : Star, U : Star](f : Function T U, x : Polynomial T) : Polynomial U =
  Polynomial (Map_List f (Coefficients x))
`Def Minus[T : Star]<Add T, Negate T>(x : T) = Map (Add x) Negate
Def Minus[A : Star](Add_A : Function A (Function A A), Negate_A : Function A A, x : A, y : A) : A = Add_A x (Negate_A y)
Def Multiply_Complex[T : Star]
  (
    Add_T : Function T (Function T T),
    Multiply_T : Function T (Function T T),
    Negate_T : Function T T,
    x : Complex T,
    y : Complex T) :
      Complex T =
        (a ->
          (b ->
            (c ->
              (d ->
                Complex (Minus Add_T Negate_T (Multiply_T a c) (Multiply_T b d)) (Add_T (Multiply_T a d) (Multiply_T b c)))
                (Imaginary y))
              (Real y))
            (Imaginary x))
          (Real x)
Def Multiply_Logical(x : Logical, y : Logical) : Logical = Match x {
  False -> False,
  True -> y}
Def Multiply_Trivial : Function Trivial (Function Trivial Trivial) = Trivial_binary
Def Not(x : Logical) : Logical = Match x {
  False -> True,
  True -> False}
~/
Def Not_Equal[T : Star]<Compare T>(x : T, y : T) : Logical = Match Compare x y {
  EQ -> False,
  Default -> True}
/~
Def Not_Equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  EQ -> False,
  Default -> True}
Instance Ring(Int)(
  Add = Add_Int,
  Convert = Id,
  Inverse = Crash,
  Multiply = Multiply_Int,
  Negate = Negate_Int)
Def Sum[T : Star, F : Arrow Star Star]
  (
    Add_T : Function T (Function T T),
    Convert_T : Function Int T,
    f : Function (Function T (Function T T)) (Function T (Function (F T) T))) :
      Function (F T) T =
        f Add_T (Zero Convert_T)
Def Trivial_binary(_ : Trivial, _ : Trivial) : Trivial = Trivial
`Def Zero[T : Star]<Convert T> : T = Convert 0
Def Zero[A : Star](Convert_A : Function Int A) : A = Convert_A 0
Def Zip[F : Arrow Star Star, T : Star, U : Star, V : Star](
  Apply_F' : Function (F (Function T (Function U V))) (Function (F T) (F (Function U V))),
  Apply_F'' : Function (F (Function U V)) (Function (F U) (F V)),
  Lift_F : Function (Function T (Function U V)) (F (Function T (Function U V))),
  f : Function T (Function U V),
  x : F T) : Function (F U) (F V) =
    Apply_F'' (Map_Functor Apply_F' Lift_F f x)
Def Zip_Pair
  [A : Star, B : Star, C : Star, D : Star, E : Star, F : Star]
  (f : Function A (Function B C), g : Function D (Function E F), x : Pair A D, y : Pair B E) :
  Pair C F =
    Pair (f (First x) (First y)) (g (Second x) (Second y))
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````