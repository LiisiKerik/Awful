`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
`Struct Array[N : #, T : Star](Array_function : Finite N -> T)
Struct Complex[T : Star](Real : T, Imaginary : T)
Algebraic Either[A : Star, B : Star](Left A, Right B)
Struct Fraction[T : Star](Numerator : T, Denominator : T)
Algebraic List[A : Star](Cons A (List A), Empty)
Algebraic Logical(False, True)
Struct Pair[A : Star, B : Star](First : A, Second : B)
Struct Polynomial[T : Star](Coefficients : List T)
Struct Quaternion[T : Star](Qx : T, Qy : T, Qz : T, Qw : T)
Struct Trivial
`Abstract All{T : Star} : List T
`Abstract Apply{F : Arrow Star Star}[T : Star, U : Star] : F (T -> U) -> F T -> F U
`Abstract Det{F : Arrow Star Star}[T : Star] : F T -> T
`Abstract Fold{F : Arrow Star Star}[T : Star, U : Star] : (T -> U -> U) -> U -> F T -> U
`Abstract Map{F : Arrow Star Star}[T : Star, U : Star] : (T -> U) -> F T -> F U
`Abstract Top_row{F : # -> * -> *}[N : #, T : Star] : F N T -> Array (N - 1) T
`Instance Add{Array _ T}<Add T> = Map Apply (Map Add)
`Instance All{Comparison} = Cons LT (Cons EQ (Cons GT Empty))
Def Add_Complex[T : Star](Add_T : Function T (Function T T)) : Function (Complex T) (Function (Complex T) (Complex T)) =
  Add_Functor Add_T Apply_Complex Apply_Complex Lift_Complex
Def Add_Logical : Function Logical (Function Logical Logical) = Not_Equal Compare_Logical
`Instance Add{Pair T U}<Add T, Add U> = Zip_Pair Add Add
Def Add_Pair[A : Star, B : Star] :
  Function
    (Function A (Function A A))
    (Function (Function B (Function B B)) (Function (Pair A B) (Function (Pair A B) (Pair A B)))) =
      Zip_Pair
`Instance Add{Maybe T}<Add T> = Add_Functor
Def Add_Maybe[T : Star](Add_T : Function T (Function T T)) : Function (Maybe T) (Function (Maybe T) (Maybe T)) =
  Add_Functor Add_T Apply_Maybe Apply_Maybe Lift_Maybe
`Instance Add{Trivial} = Trivial_binary
Def Add_Trivial : Function Trivial (Function Trivial Trivial) = Trivial_binary
`Instance Add{F T}<Add T, Apply F, Lift F> = Zip Add
Def Add_Functor[T : Star, F : Arrow Star Star]
  (
    Add_T : Function T (Function T T),
    Apply_F' : Function (F (Function T (Function T T))) (Function (F T) (F (Function T T))),
    Apply_F'' : Function (F (Function T T)) (Function (F T) (F T)),
    Lift_F : Function (Function T (Function T T)) (F (Function T (Function T T)))) :
      Function (F T) (Function (F T) (F T)) =
        Zip Apply_F' Apply_F'' Lift_F Add_T
Def All_Comparison : List Comparison = Cons LT (Cons EQ (Cons GT Empty))
Def All_Complex[T : Star](All_T : List T) : List (Complex T) = Zip Apply_List Apply_List Lift_List Complex All_T All_T
Def All_Either[T : Star, U : Star](All_T : List T, All_U : List U) : List (Either T U) =
  Join_List (Map_List Left All_T) (Map_List Right All_U)
Def All_Function[T : Star, U : Star](All_T : List T, All_U : List U) : List (Function T U) = Crash
`Instance All{Logical} = Cons False (Cons True Empty)
Def All_Logical : List Logical = Cons False (Cons True Empty)
`Instance All{Pair T U}<All T, All U> = Zip Pair All All
Def All_Pair[T : Star, U : Star](All_T : List T, All_U : List U) : List (Pair T U) =
  Zip Apply_List Apply_List Lift_List Pair All_T All_U
`Instance All{Trivial} = Cons Trivial Empty
Def All_Trivial : List Trivial = Cons Trivial Empty
`Instance Add{Logical} = Not_Equal
~/
Instance Apply{Array _} x y = Array (Apply (Array_function x) (Array_function y))
Def Apply_Array[N : #, T : Star, U : Star](x : Array N (T -> U), y : Array N T) : Array N U =
  Array (Apply_Function (Array_function x) (Array_function y))
Def Apply_Array[A : Star, B : Star](x : Array (Function A B), y : Array A) : Maybe (Array B) =
  Match Equal_Int (Length x) (Length y) {
    False -> Nothing,
    True -> Array (Length x) (z -> (Unsafe_Index x z) (Unsafe_Index y z))}
/~
`Instance Apply{Complex} x y = Complex (Real x (Real y)) (Imaginary x (Imaginary y))
Def Apply_Complex[T : Star, U : Star](x : Complex (Function T U), y : Complex T) : Complex U =
  Complex (Real x (Real y)) (Imaginary x (Imaginary y))
Def Apply_Either[A : Star, B : Star, C : Star](x : Either A (Function B C), y : Either A B) : Either A C = Match x {
  Left z -> Left z,
  Right f -> Map_Either f y}
`Instance Apply{Function _} f g x = f x (g x)
Def Apply_Function[A : Star, B : Star, C : Star](f : Function A (Function B C), g : Function A B, x : A) : C = f x (g x)
Def Apply_List[T : Star, U : Star](x : List (Function T U), y : List T) : List U = Match x {
  Cons f z -> Join_List (Map_List f y) (Apply_List z y),
  Empty -> Empty}
Def Apply_Maybe[A : Star, B : Star](x : Maybe (Function A B), y : Maybe A) : Maybe B = Match x {
  Nothing -> Nothing,
  Wrap f -> Map_Maybe f y}
Def Bimap[T : Star, U : Star, V : Star, W : Star](f : Function T U, g : Function V W, x : Pair T V) : Pair U W =
  Pair (f (First x)) (g (Second x))
Def Clean[T : Star](Equal_T : Function T (Function T Logical), x : List T) : List T = Match x {
  Cons y z -> (w -> (a -> Match Equal_T y Crash {
    False -> a,
    True -> Match w {
      Cons -> a,
      Empty -> Empty}}) (Cons y w)) (Clean Equal_T z),
  Empty -> Empty}
Def Compare_Comparison(x : Comparison, y : Comparison) : Comparison = Match x {
  LT -> Match y {
    LT -> EQ,
    Default -> LT},
  EQ -> Match y {
    LT -> GT,
    EQ -> EQ,
    GT -> LT},
  GT -> Match y {
    GT -> EQ,
    Default -> GT}}
Def Compare_Either[T : Star, U : Star]
  (
    Compare_T : Function T (Function T Comparison),
    Compare_U : Function U (Function U Comparison),
    x : Either T U,
    y : Either T U) :
      Comparison =
        Match x {
          Left z -> Match y {
            Left w -> Compare_T z w,
            Right -> LT},
          Right z -> Match y {
            Left -> GT,
            Right w -> Compare_U z w}}
Def Compare_Function[T : Star, U : Star]
  (All_T : List T, Compare_U : Function U (Function U Comparison), f : Function T U, g : Function T U) : Comparison =
    Compare_List Compare_U (Map_List f All_T) (Map_List g All_T)
Def Compare_List[T : Star](Compare_T : Function T (Function T Comparison), x : List T, y : List T) : Comparison = Match x {
  Cons z w -> Match y {
    Cons a b -> (c -> Match c {
      EQ -> Compare_List Compare_T w b,
      Default -> c}) (Compare_T z a),
    Empty -> GT},
  Empty -> Match y {
    Cons -> LT,
    Empty -> EQ}}
Def Compare_Logical(x : Logical, y : Logical) : Comparison = Match x {
  False -> Match y {
    False -> EQ,
    True -> LT},
  True -> Match y {
    False -> GT,
    True -> EQ}}
Def Compare_Maybe[T : Star](Compare_T : Function T (Function T Comparison), x : Maybe T, y : Maybe T) : Comparison =
  Match x {
    Nothing -> Match y {
      Nothing -> EQ,
      Wrap -> LT},
    Wrap z -> Match y {
      Nothing -> GT,
      Wrap w -> Compare_T z w}}
Def Compare_Pair[T : Star, U : Star]
  (
    Compare_T : Function T (Function T Comparison),
    Compare_U : Function U (Function U Comparison),
    x : Pair T U,
    y : Pair T U) :
      Comparison =
        Match Compare_T (First x) (First y) {
          EQ -> Compare_U (Second x) (Second y),
          GT -> GT,
          LT -> LT}
Def Compare_Trivial(_ : Trivial, _ : Trivial) : Comparison = EQ
Def Convert_Complex[T : Star](Convert_T : Function Int T, x : Int) : Complex T = Complex (Convert_T x) (Zero Convert_T)
`Instance Convert{Int} = Id
Def Convert_Int : Function Int Int = Id
`Instance Convert{Logical} x = Equal (Mod x 2) 1
Def Convert_Logical(x : Int) : Logical = Equal Compare_Int (Mod_Int x 2) 1
Def Convert_Polynomial[T : Star]
  (Convert_T : Function Int T, Equal_T : Function T (Function T Logical), x : Int) : Polynomial T =
    Polynomial (Clean Equal_T (Lift_List (Convert_T x)))
`Instance Convert{Trivial} _ = Trivial
Def Convert_Trivial(_ : Int) : Trivial = Trivial
Def Det_Complex[T : Star](Add_T : Function T (Function T T), Multiply_T : Function T (Function T T), x : Complex T) : T =
  Add_T (Crash (Real x)) (Crash (Imaginary x))
Def Equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  EQ -> True,
  Default -> False}
Def Filter_List[T : Star](f : Function T Logical, x : List T) : List T = Match x {
  Cons y z -> (w -> Match f y {
    False -> w,
    True -> Cons y w}) (Filter_List f z),
  Empty -> Empty}
Def Filter_Maybe[T : Star](f : Function T Logical, x : Maybe T) : Maybe T = Match x {
  Nothing -> Nothing,
  Wrap y -> Match f y {
    False -> Nothing,
    True -> x}}
Def Flatten_Either[T : Star, U : Star](x : Either T (Either T U)) : Either T U = Match x {
  Left y -> Left y,
  Right y -> y}
Def Flatten_Function[T : Star, U : Star](f : Function T (Function T U), x : T) : U = f x x
Def Flatten_List[T : Star](x : List (List T)) : List T = Match x {
  Cons y z -> Join_List y (Flatten_List z),
  Empty -> Empty}
Def Flatten_Maybe[T : Star](x : Maybe (Maybe T)) : Maybe T = Match x {
  Nothing -> Nothing,
  Wrap y -> y}
Def Flip[A : Star, B : Star, C : Star](f : Function A (Function B C), x : B, y : A) : C = f y x
`Instance Fold{Complex} f x y = Crash
Def Fold_Left[T : Star, U : Star](f : Function T (Function U T), x : T, y : List U) : T = Match y {
  Cons z w -> Fold_Left f (f x z) w,
  Empty -> x}
Def Fold_Right[T : Star, U : Star](f : Function T (Function U U), x : U, y : List T) : U = Match y {
  Cons z w -> f z (Fold_Right f x y),
  Empty -> x}
Def Greater[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  GT -> True,
  Default -> False}
Def Greater_or_equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical =
  Match Compare_T x y {
    LT -> False,
    Default -> True}
Def Id[A : Star](x : A) : A = x
`Def Identity[T : Star]<Convert T> : T = Convert 0
Def Identity[A : Star](Convert_A : Function Int A) : A = Convert_A 1
`Instance Inverse{Trivial} = Wrap
Def Inverse_Trivial : Function Trivial (Maybe Trivial) = Wrap
~/
Def Join_Array[A : Star](x : Array A, y : Array A) : Array A =
  Unsafe_Array (Add_Int (Length x) (Length y)) (z -> Match Less_Int z (Length x) {
    False -> Unsafe_Index y (Minus Add_Int Negate_Int z (Length x)),
    True -> Unsafe_Index x z})
/~
Def Join_List[T : Star](x : List T, y : List T) : List T = Match x {
  Cons z w -> Cons z (Join_List w y),
  Empty -> y}
~/
Def Lead_Complex[T : Star] : Function (Complex T) T = Real
Def Lead_Quaternion[T : Star] : Function (Quaternion T) T = Qx
Def Less[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  LT -> True,
  Default -> False}
Def Less_or_equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  GT -> False,
  Default -> True}
Instance Lift{Array _} = Map Array Lift
Def Lift_Array[N : #, T : Star] : T -> Array N T = Map_Function Array Lift_Function
Def Lift_Array[A : Star](x : Int, y : A) : Maybe (Array A) = Array x (Lift_Function y)
/~
`Instance Lift{Complex} x = Complex x x
Def Lift_Complex[T : Star](x : T) : Complex T = Complex x x
`Instance Lift{Either _} = Right
Def Lift_Either[A : Star, B : Star] : Function B (Either A B) = Right
`Instance Lift{Function _} x _ = x
Def Lift_Function[A : Star, B : Star](x : A, _ : B) : A = x
Def Lift_List[T : Star](x : T) : List T = Cons x Empty
`Instance Lift{Maybe} = Wrap
Def Lift_Maybe[T : Star] : Function T (Maybe T) = Wrap
~/
Instance Map{Array _} x y = Array (Map x (Array_function y))
Def Map_Array[T : Star, U : Star, N : #](x : T -> U, y : Array N T) : Array N U = Array (Map_Function x (Array_function y))
Def Map_Array[A : Star, B : Star](f : Function A B, x : Array A) : Array B =
  Unsafe_Array (Length x) (y -> f (Unsafe_Index x y))
/~
`Instance Map{Complex} = Map_Functor
Def Map_Complex[T : Star, U : Star] : Function (Function T U) (Function (Complex T) (Complex U)) =
  Map_Function Apply_Complex Lift_Complex
Def Map_Either[A : Star, B : Star, C : Star](f : Function A B, x : Either C A) : Either C B = Match x {
  Left y -> Left y,
  Right y -> Right (f y)}
`Instance Map{Function _} f g x = f (g x)
Def Map_Function[A : Star, B : Star, C : Star](f : Function A B, g : Function C A, x : C) : B = f (g x)
Def Map_Functor[F : Arrow Star Star, T : Star, U : Star]
  (
    Apply_T : Function (F (Function T U)) (Function (F T) (F U)),
    Lift_T : Function (Function T U) (F (Function T U)),
    f : Function T U) :
      Function (F T) (F U) =
        Apply_T (Lift_T f)
Def Map_List[T : Star, U : Star](f : Function T U, x : List T) : List U = Match x {
  Cons y z -> Cons (f y) (Map_List f z),
  Empty -> Empty}
Def Map_Maybe[A : Star, B : Star](f : Function A B, x : Maybe A) : Maybe B = Match x {
  Nothing -> Nothing,
  Wrap y -> Wrap (f y)}
`Instance Map{Pair _} f x = Pair (First x) (f (Second x))
Def Map_Pair[A : Star, B : Star, C : Star](f : Function A B, x : Pair C A) : Pair C B = Pair (First x) (f (Second x))
Def Map_Polynomial[T : Star, U : Star](f : Function T U, x : Polynomial T) : Polynomial U =
  Polynomial (Map_List f (Coefficients x))
`Def Minus[T : Star]<Add T, Negate T>(x : T) = Map (Add x) Negate
Def Minus[A : Star](Add_A : Function A (Function A A), Negate_A : Function A A, x : A, y : A) : A = Add_A x (Negate_A y)
Def Multiply_Complex[T : Star]
  (
    Add_T : Function T (Function T T),
    Multiply_T : Function T (Function T T),
    Negate_T : Function T T,
    x : Complex T,
    y : Complex T) :
      Complex T =
        (a ->
          (b ->
            (c ->
              (d ->
                Complex (Minus Add_T Negate_T (Multiply_T a c) (Multiply_T b d)) (Add_T (Multiply_T a d) (Multiply_T b c)))
                (Imaginary y))
              (Real y))
            (Imaginary x))
          (Real x)
Def Multiply_Logical(x : Logical, y : Logical) : Logical = Match x {
  False -> False,
  True -> y}
Def Multiply_Trivial : Function Trivial (Function Trivial Trivial) = Trivial_binary
Def Not(x : Logical) : Logical = Match x {
  False -> True,
  True -> False}
~/
Def Not_Equal[T : Star]<Compare T>(x : T, y : T) : Logical = Match Compare x y {
  EQ -> False,
  Default -> True}
/~
Def Not_Equal[T : Star](Compare_T : Function T (Function T Comparison), x : T, y : T) : Logical = Match Compare_T x y {
  EQ -> False,
  Default -> True}
Def Sum[T : Star, F : Arrow Star Star]
  (
    Add_T : Function T (Function T T),
    Convert_T : Function Int T,
    f : Function (Function T (Function T T)) (Function T (Function (F T) T))) :
      Function (F T) T =
        f Add_T (Zero Convert_T)
Def Trivial_binary(_ : Trivial, _ : Trivial) : Trivial = Trivial
`Def Zero[T : Star]<Convert T> : T = Convert 0
Def Zero[A : Star](Convert_A : Function Int A) : A = Convert_A 0
Def Zip[F : Arrow Star Star, T : Star, U : Star, V : Star](
  Apply_F' : Function (F (Function T (Function U V))) (Function (F T) (F (Function U V))),
  Apply_F'' : Function (F (Function U V)) (Function (F U) (F V)),
  Lift_F : Function (Function T (Function U V)) (F (Function T (Function U V))),
  f : Function T (Function U V),
  x : F T) : Function (F U) (F V) =
    Apply_F'' (Map_Functor Apply_F' Lift_F f x)
Def Zip_Pair
  [A : Star, B : Star, C : Star, D : Star, E : Star, F : Star]
  (f : Function A (Function B C), g : Function D (Function E F), x : Pair A D, y : Pair B E) :
  Pair C F =
    Pair (f (First x) (First y)) (g (Second x) (Second y))
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````