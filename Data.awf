````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Load (Standard.awf)
Syntax $Dictionary ($x :: [Expr]) :: Expr = Dictionary ($List $x)
Syntax $Set ($x :: [Expr]) :: Expr = Set ($List $x)
Data Dictionary [T : Star, U : Star] = Struct !Dictionary' (Entries : List (T * U))
Data Set [T : Star] = Struct !Set' (Elements : List T)
Def !All_Dictionary [T : Star, U : Star] <Finite U> (x : List T) : List (List (T * U)) =
  Match x {
    Empty_List -> Lift Empty_List,
    y ; z -> Let a = All_Dictionary z In a :+ Bind (b -> Bind (Construct_List (y & b)) a) All}
Def !All_Set [T : Star] (x : List T) : List (List T) =
  Match x {Empty_List -> Lift Empty_List, y ; z -> Let a = All_Set z In a :+ Bind (Construct_List y) a}
Def !And_Set [T : Star] <Ord T> (x : List T, y : List T) : List T =
  Match x & y {
    z : a & b : c -> Match Compare z b {LT -> And_Set a y, EQ -> z : And_Set a c, GT -> And_Set x c},
    _ -> Empty_List}
Instance Comp_lattice {Set T} <Finite T> (Not (Set x) = Set (Not_Set All x))
Def !Compare_Dictionary [T : Star, U : Star] <Ord T, Ord U> (x : List (T * U), y : List (T * U)) : Ordering =
  Match x & y {
    Empty_List & Empty_List -> EQ,
    Empty_List & _ -> LT,
    _ & Empty_List -> GT,
    (z & a) : b & (c & d) : e ->
      Match Compare z c {LT -> GT, EQ -> Match Compare a d {LT -> LT, EQ -> Compare_Dictionary b e, GT -> GT}, GT -> LT}}
Def !Compare_Set [T : Star] <Ord T> (x : List T, y : List T) : Ordering =
  Match x & y {
    Empty_List & Empty_List -> EQ,
    Empty_List & _ -> LT,
    _ & Empty_List -> GT,
    z : a & b : c -> Match Compare z b {LT -> GT, EQ -> Compare_Set a c, GT -> LT}}
Instance Container {Dictionary T} (
  Contains x (Dictionary' y) = Contains x (Second . y),
  Empty = Dictionary' Empty_List,
  Filter f (Dictionary' x) = Dictionary' (Filter (f . Second) x),
  Size (Dictionary' x) = Size x)
Instance Container {Set} (
  Contains x (Set' y) = Contains_Set x y,
  Empty = Set' Empty_List,
  Filter f (Set' x) = Set' (Filter f x),
  Size (Set' x) = Size x)
Def !Contains_Set [T : Star, U : Star] <Ord T> (x : T, y : List T) : Logical =
  Match y {Empty_List -> False, z : a -> Match Compare x z {LT -> Contains_Set x a, EQ -> True, GT -> False}}
Def Delete_from_Dictionary [T : Star, U : Star] <Ord T> (x : T, Dictionary' y : Dictionary T U) : Dictionary T U =
  Dictionary' (Delete_from_Dictionary' x y)
Def !Delete_from_Dictionary' [T : Star, U : Star] <Ord T> (x : T, y : List (T * U)) : List (T * U) =
  Match y {
    Empty_List -> Empty_List,
    (z & a) : b -> Match Compare x z {LT -> y, EQ -> b, GT -> (z & a) : Delete_from_Dictionary' x b}}
Def Delete_from_Set [T : Star] <Ord T> (x : T, Set' y : Set T) : Set T = Set' (Delete_from_Set' x y)
Def Delete_from_Set' [T : Star] <Ord T> (x : T, y : List T) : List T =
  Match y {Empty_List -> Empty_List, z : a -> Match x z {LT -> y, EQ -> a, GT -> Delete_from_Set' x a}}
Def Dictionary
Def Entry [T : Star, U : Star] <Ord T> (x : T, Dictionary' y : Dictionary T U) : Maybe U = Entry' x y
Def !Entry' [T : Star, U : Star] <Ord T> (x : T, y : List (T * U)) : Maybe U =
  Match y {Empty_List -> Nothing, (z & a) : b -> Match Compare x z {LT -> Nothing, EQ -> Wrap a, GT -> Entry' x b}}
Instance Finite {Dictionary T} (All = Dictionary' . All_Dictionary All)
Instance Finite {Set T} (All = Set' . All_Set All)
Instance Functor {Dictionary T} (f . Dictionary x = Dictionary' (Apply_right f . x))
Def Insert_into_dictionary [T : Star, U : Star] <Ord T> (x : T, y : U, Dictionary' z : Dictionary T U) : U + Dictionary T U =
  Dictionary' . Insert_into_dictionary' x y z
Def Insert_into_dictionary' [T : Star, U : Star] <Ord T> (x : T, y : U, z : List (T * U)) : U + List (T * U) =
  Match z {
    Empty_List -> Lift (x & y),
    (a & b) : c ->
      Match Compare x a {LT -> Right ((x & y) : z), EQ -> Left b, GT -> Construct_List (a & b) . Insert_into_dictionary' x y c}}
Def Insert_into_set [T : Star] <Ord T> (x : T, Set' y : Set T) : Maybe (Set T) = Set' . Insert_into_set' x y
Def Insert_into_set' [T : Star] <Ord T> (x : T, y : List T) : Maybe (List T) =
  Match y {
    Empty_List -> Lift x,
    z : a -> Match Compare x z {LT -> Wrap (x : y), EQ -> Nothing, GT -> Construct_List z . Insert_into_set' x a}}
Def Join [T : Star, U : Star] (
  f : T -> T -> T,
  Dictionary' x : Dictionary U T,
  Dictionary' y : Dictionary U T) : Dictionary U T =
    Dictionary' (Join' f x y)
Def !Join' [T : Star, U : Star] <Ord U> (f : T -> T -> T, x : List (U * T), y : List (U * T)) : List (U * T) =
  Let
    g z a b c = (z & a) : Join' f b c
  In
    Match x & y {
      Empty_List & _ -> y,
      _ & Empty_List -> x,
      (z & a) : b & (c & d) : e -> Match Compare z c {LT -> g z a b y, EQ -> g z (f a d) b e, GT -> g c d x e}}
Instance Lattice {Set T} <Ord T> (Set' x /\ Set' y = Set' (And_Set x y), Min = Empty, Set' x \/ Set' y = Set' (Or_Set x y))
Instance Max_lattice {Set T} <Finite T> (Max = Set' All)
Instance Min_lattice {Set T} <Ord T> (Min = Empty)
Def !Not_Set [T : Star] <Ord T> (x : List T, y : List T) : List T =
  Match x & y {_ & Empty_List -> Empty_List, z : a & b : c -> Match Compare z b {LT -> z : Not_Set a y, EQ -> Not_Set a c}}
Def !Or_Set [T : Star] <Ord T> (x : List T, y : List T) : List T =
  Let
    f z a b = z : Or_Set a b
  In
    Match x & y {
      Empty_List & _ -> y,
      _ & Empty_List -> x,
      z : a & b : c -> Match Compare z b {LT -> f z a y, EQ -> f z a c, GT -> f b x c}}
Instance Ord {Dictionary T U} <Ord T, Ord U> (Compare (Dictionary' x) (Dictionary' y) = Compare_Dictionary x y)
Instance Ord {Set T} <Ord T> (Compare (Set' x) (Set' y) = Compare_Set x y)
Def Set
Def Union [T : Star, U : Star] <Ord T, Ord U> (
  Dictionary' x : Dictionary T U,
  Dictionary' y : Dictionary T U) : Maybe (Dictionary T U) =
    Dictionary' . Union' x y
Def !Union' [T : Star, U : Star] <Ord T, Ord U> (x : List (T * U), y : List (T * U)) : Maybe (List (T * U)) =
  Let
    f z a b c = Construct_List (z & a) . Union' b c
  In
    Match x & y {
      Empty_List & _ -> Wrap y,
      _ & Empty_List -> Wrap x,
      (z & a) : b & (c & d) : e ->
        Match Compare z c {LT -> f z a b y, EQ -> Match Compare a d {EQ -> f z a b e, _ -> Nothing}, GT -> f c d x e}}
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
`Def Sort [T : Star] <Ord T> (x : List T) : List T = Let y & z = Split_0 x In Merge
~/
Def Write_Empty : Op = Write_name ($List ["E", "m", "p", "t", "y"])
Instance Writeable {Dictionary T U} <Writeable T, Writeable U> (
  Write_brackets (Dictionary' x) =
    Match x {
      Empty_List -> Write_Empty,
      _ -> Write_List ($List ["$", "D", "i", "c", "t", "i", "o", "n", "a", "r", "y"]) x})
Instance Writeable {Set T} <Writeable T> (
  Write_Brackets (Set' x) = Match x {Empty_List -> Write_Empty, _ -> Write_List ($List ["$", "S", "e", "t"]) x})
/~