````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Syntax !List :: [Expr] -> Expr = !foldr Construct_List Empty_List
Syntax !foldr(!f :: Expr, !x :: Expr, !y :: [Expr]) :: Expr = case !y of {[] -> !x, !z : !a -> !f !z (!foldr !f !x !a)}
Algebraic Logical{False, True}
Class Applicative{F : Star -> Star}<Functor>(Compose[T : Star, U : Star] : F (T -> U) -> F T -> F U, Lift[T : Star] : T -> F T)
Class Braided{F : Star -> Star -> Star}(
  Apply'[T : Star, U : Star, V : Star, W : Star] : (T -> U) -> (V -> W) -> F T V -> F U W,
  Associate_left[T : Star, U : Star, V : Star] : F T (F U V) -> F (F T U) V,
  Associate_right[T : Star, U : Star, V : Star] : F (F T U) V -> F T (F U V),
  Commute[T : Star, U : Star] : F T U -> F U T)
Class Finite{T : Star}<Ord>(All : List T)
Class Foldable{F : Star -> Star}(
  Fold_left[T : Star, U : Star] : (T -> U -> T) -> T -> F U -> T,
  Fold_right[T : Star, U : Star] : (T -> U -> U) -> U -> F T -> U)
Class Functor{F : Star -> Star}(Apply[T : Star, U : Star] : (T -> U) -> F T -> F U)
Class Monad{F : Star -> Star}<Applicative>(Bind[T : Star, U : Star] : F T -> (T -> F U) -> F U)
Operator ! Compose 5 Left
Operator & Pair 6 Right
Operator % Mod 0 Left
Operator * Multiply 0 Left
Operator + Add 1 Left
Operator - Minus 1 Left
Operator . Apply 5 Left
Operator .. Apply' 5 Right
Operator ... Write' 5 Left
Operator / Div_right 0 Left
Operator /\ Max 3 Left
Operator /-\ Nand 3 Left
Operator : Construct_List 7 Right
Operator < Less 2 Left
Operator <= Less_or_equal 2 Left
Operator =/ Not_equal 2 Left
Operator == Equal 2 Left
Operator =?= Compare 2 Left
Operator > Greater 2 Left
Operator >= Greater_or_equal 2 Left
Operator \ Div_left 0 Left
Operator \/ Min 4 Left
Operator \-/ Nor 4 Left
Operator | Div 0 Left
Operator ~ Bind 5 Right
Def All_Modular[N : Nat]<Nonzero N>(x : Modular N) : List (Modular N) =
  Let y = x + Id In Construct_List x (Match Is_Zero y {False -> All_Modular y, True -> Empty_List})
Instance Applicative{Either _}(Compose x y = Match x {Left z -> Left z, Right f -> f . y}, Lift = Right)
Instance Applicative{Function _}(Compose f g x = f x (g x), Lift x _ = x)
Instance Applicative{List}(
  Compose x y = Match x {Empty_List -> Empty_List, Construct_List f z -> Cat (f . y) (z ! y)},
  Lift x = !List ![x])
Instance Applicative{Maybe}(Compose x y = Match x {Nothing -> Nothing, Wrap f -> f . y}, Lift = Wrap)
Def Apply_left[T : Star, U : Star, F : Star -> Star -> Star, V : Star]<Braided F>(f : T -> U) : F T V -> F U V = f .. Identity
Def Apply_right[T : Star, U : Star, F : Star -> Star -> Star, V : Star]<Braided F> : (T -> U) -> F V T -> F V U =
  Apply' Identity
Def Brackets[T : Star]<Writeable T>(x : Int, y : T) : List Char =
  Let Pair z a = Write_brackets y In Match x =?= a {LT -> Cat (Lift "(") (Cat z (Lift ")")), _ -> z}
Instance Braided{Either}(
  Apply' f g x = Match x {Left y -> Left (f y), Right y -> Right (g y)},
  Associate_left x = Match x {Left y -> Left (Left y), Right y -> Match y {Left z -> Left (Right z), Right z -> Right z}},
  Associate_right x = Match x {Left y -> Match y {Left z -> Left z, Right z -> Right (Left z)}, Right y -> Right (Right y)},
  Commute x = Match x {Left y -> Right y, Right y -> Left y})
Instance Braided{Pair}(
  Apply' f g (Pair x y) = Pair (f x) (g y),
  Associate_left (Pair x (Pair y z)) = Pair (Pair x y) z,
  Associate_right (Pair (Pair x y) z) = Pair x (Pair y z),
  Commute (Pair x y) = Pair y x)
Def Cat[T : Star](x : List T, y : List T) : List T = Match x {Empty_List -> y, Construct_List z a -> Construct_List z (Cat a y)}
Def Convert'[F : Star -> Star, T : Star]<Applicative F, Ring T>(x : Int) : F T = Lift (Convert x)
Def Div_left[T : Star]<Field T>(x : T, y : T) : Maybe T = (z -> z * y) . Inverse x
Def Div_right[T : Star]<Field T>(x : T, y : T) : Maybe T = Multiply x . Inverse y
Def Equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {EQ -> True, _ -> False}
Instance Field{Int}(Inverse x = Match x {-1 -> Wrap -1, 1 -> Wrap 1, _ -> Nothing})
Instance Field{Logical}(Inverse x = Match x {False -> Nothing, True -> Wrap True})
Instance Field{Pair T U}<Field T, Field U>(Inverse (Pair x y) = Zip Pair (Inverse x) (Inverse y))
Instance Finite{Comparison}(All = !List ![LT,  EQ,  GT])
Instance Finite{Either T U}<Finite T, Finite U>(All = Cat (Left . All) (Right . All))
Instance Finite{Logical}(All = !List ![False, True])
Instance Finite{Maybe T}<Finite T>(All = Construct_List Nothing (Wrap . All))
Instance Finite{Modular N}(All = Branch N {Zero -> Empty_List, Next N' -> All_Modular Zr})
Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Pair All All)
Def Flatten[F : Star -> Star, T : Star]<Monad F>(x : F (F T)) : F T = Bind x Identity
Instance Foldable{List}(
  Fold_left f x y = Match y {Empty_List -> x, Construct_List z a -> Fold_left f (f x z) a},
  Fold_right f x y = Match y {Empty_List -> x, Construct_List z a -> f z (Fold_right f x a)})
Instance Foldable{Maybe}(
  Fold_left f x y = Match y {Nothing -> x, Wrap z -> f x z},
  Fold_right f x y = Match y {Nothing -> x, Wrap z -> f z x})
Instance Functor{Either _}(Apply = Apply_right)
Instance Functor{Function _}(Apply f g x = f (g x))
Instance Functor{List}(Apply f x = Match x {Empty_List -> Empty_List, Construct_List y z -> Construct_List (f y) (f . z)})
Instance Functor{Maybe}(Apply f x = Match x {Nothing -> Nothing, Wrap y -> Wrap (f y)})
Instance Functor{Pair _}(Apply = Apply_right)
Def Greater[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {GT -> True, _ -> False}
Def Greater_or_equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {LT -> False, _ -> True}
Def Id[T : Star]<Ring T> : T = Convert 1
Def Identity[T : Star](x : T) : T = x
Def Interleave[T : Star](x : List T, y : List (List T)) : List T =
  Match y {Empty_List -> Empty_List, Construct_List z a -> Cat z (Flatten (Cat x . a))}
Def Is_Zero[T : Star]<Ord T, Ring T> : T -> Logical = Equal Zr
Def Less[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {LT -> True, _ -> False}
Def Less_or_equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {GT -> False, _ -> True}
Def Max[T : Star]<Ord T>(x : T, y : T) : T = Match Compare x y {LT -> y, _ -> x}
Def Min[T : Star]<Ord T>(x : T, y : T) : T = Match Compare x y {LT -> x, _ -> y}
Def Minus[T : Star]<Ring T>(x : T, y : T) : T = x + Negate y
Instance Monad{Either _}(Bind x f = Match x {Left y -> Left y, Right y -> f y})
Instance Monad{Function _}(Bind f g x = g (f x) x)
Instance Monad{List}(Bind x f = Match x {Empty_List -> Empty_List, Construct_List y z -> Cat (f y) (Bind z f)})
Instance Monad{Maybe}(Bind x f = Match x {Nothing -> Nothing, Wrap y -> f y})
Def Multiply'[F : Star -> Star, T : Star]<Applicative F, Ring T> : F T -> F T -> F T = Zip Multiply
Def Nand(x : Logical, y : Logical) : Logical = Not (Min x y)
Def Negate'[F : Star -> Star, T : Star]<Functor F, Ring T> : F T -> F T = Apply Negate
Def Nor(x : Logical, y : Logical) : Logical = Not (Max x y)
Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}
Def Not_equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {EQ -> False, _ -> True}
Instance Ord{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, _ -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, _ -> GT}})
Instance Ord{Either T U}<Ord T, Ord U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right _ -> LT},
      Right z -> Match y {Left _ -> GT, Right w -> Compare z w}})
Instance Ord{List T}<Ord T>(
  Compare x y =
    Match x {
      Empty_List -> Match y {Empty_List -> EQ, Construct_List _ _ -> LT},
      Construct_List z a -> Match y {Empty_List -> GT, Construct_List b c -> Compare (Pair z a) (Pair b c)}})
Instance Ord{Logical}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Instance Ord{Maybe T}<Ord T>(
  Compare x y =
    Match x {Nothing -> Match y {Nothing -> EQ, Wrap _ -> LT}, Wrap z -> Match y {Nothing -> GT, Wrap w -> Compare z w}})
Instance Ord{Pair T U}<Ord T, Ord U>(
  Compare (Pair x y) (Pair z a) = Match Compare x z {LT -> LT, EQ -> Compare y a, GT -> GT})
Instance Ring{Logical}(Add = Not_equal, Convert x = Equal (Convert x) (1 # 2), Multiply = Min, Negate = Identity)
Instance Ring{Pair T U}<Ring T, Ring U>(
  Add (Pair x y) (Pair z a) = Pair (x + z) (y + a),
  Convert x = Pair (Convert x) (Convert x),
  Multiply (Pair x y) (Pair z a) = Pair (x * z) (y * a),
  Negate (Pair x y) = Pair (Negate x) (Negate y))
Def Write[T : Star]<Writeable T>(x : T) : List Char = First (Write_brackets x)
Def Write'[T : Star]<Writeable T>(x : List Char, y : T) : List Char = Cat x (Cat (Lift " ") (Brackets 0 y))
Instance Writeable{Char}(
  Write_brackets c = Pair (Match c {Newline -> !List !["N", "e", "w", "l", "i", "n", "e"], _ -> !List ![""", c, """]}) 0)
Instance Writeable{Comparison}(
  Write_brackets x = Pair (Match x {LT -> !List !["L", "T"], EQ -> !List !["E", "Q"], GT -> !List !["G", "T"]}) 0)
Instance Writeable{Either T U}<Writeable T, Writeable U>(
  Write_brackets x =
    Pair
      (Match x {
        Left y -> Cat (!List !["L", "e", "f", "t", " "]) (Brackets 0 y),
        Right y -> Cat (!List !["R", "i", "g", "h", "t", " "]) (Brackets 0 y)})
      1)
Instance Writeable{List T}<Writeable T>(
  Write_brackets x =
    Match x {
      Empty_List -> Pair (!List !["E", "m", "p", "t", "y", "_", "L", "i", "s", "t"]) 0,
      Construct_List y z ->
        Cat (!List !["!", "L", "i", "s", "t", " ", "!", "["]) (Cat (Interleave (!List ![",", " "]) (Write . x)) (Lift "]")) &
        1})
Instance Writeable{Logical}(
  Write_brackets x = Pair (Match x {False -> !List !["F", "a", "l", "s", "e"], True -> !List !["T", "r", "u", "e"]}) 0)
Instance Writeable{Maybe T}<Writeable T>(
  Write_brackets x =
    Match x {
      Nothing -> !List !["N", "o", "t", "h", "i", "n", "g"] & 0,
      Wrap y -> Cat (!List !["W", "r", "a", "p", " "]) (Brackets 0 y) & 1})
Instance Writeable{Pair T U}<Writeable T, Writeable U>(Write_brackets (Pair x y) =
  Cat (Brackets 1 x) (Cat (!List ![" ", "&", " "]) (Brackets 2 y)) & 2)
Def Zip[F : Star -> Star, T : Star, U : Star, V : Star]<Applicative F>(f : T -> U -> V, x : F T) : F U -> F V = Compose (f . x)
Def Zr[T : Star]<Ring T> : T = Convert 0
````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````