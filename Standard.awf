`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
Algebraic Either[T : Star, U : Star](Left T, Right U)
Algebraic Tree[T : Star](Empty_Tree, Construct_Tree T (Tree T) (Tree T))
Class Alternative{F : Arrow Star Star}<Applicative>(
  Cat[T : Star] : Function (F T) (Function (F T) (F T)),
  Empty[T : Star] : F T)
Class Applicative{F : Arrow Star Star}<Functor>(
  Apply[T : Star, U : Star] : Function (F (Function T U)) (Function (F T) (F U)),
  Lift[T : Star] : Function T (F T))
Class Bifunctor{F : Arrow Star (Arrow Star Star)}(
  Bimap[T : Star, U : Star, V : Star, W : Star] :
    Function (Function T U) (Function (Function V W) (Function (F T V) (F U W))))
Class Finite{T : Star}<Ord>(All : List T)
Class Functor{F : Arrow Star Star}(Fmap[T : Star, U : Star] : Function (Function T U) (Function (F T) (F U)))
Class Monad{F : Arrow Star Star}<Applicative>(Bind[T : Star, U : Star] : Function (F T) (Function (Function T (F U)) (F U)))
Class Monad'{F : Arrow Star Star}<Monad>(Unsafe[T : Star] : Function (F T) T)
Def Add'[F : Arrow Star Star, T : Star]<Applicative F, Ring T> : Function (F T) (Function (F T) (F T)) = Zip Add
Instance Alternative{List}(
  Cat x y = Match x {Empty_List -> y, Construct_List z a -> Construct_List z (Cat a y)},
  Empty = List)
Instance Alternative{Maybe}(Cat x y = Match x {Nothing -> y, Wrap _ -> x}, Empty = Nothing)
Instance Applicative{Either _}(Apply x y = Match x {Left z -> Left z, Right f -> Fmap f y}, Lift = Right)
Instance Applicative{Function _}(Apply f g x = f x (g x), Lift x _ = x)
Instance Applicative{List}(
  Apply x y = Match x {Empty_List -> List, Construct_List f z -> Cat (Fmap f y) (Apply z y)},
  Lift x = List (x))
Instance Applicative{Maybe}(Apply x y = Match x {Nothing -> Nothing, Wrap f -> Fmap f y}, Lift = Wrap)
Instance Bifunctor{Either}(Bimap f g x = Match x {Left y -> Left (f y), Right y -> Right (g y)})
Instance Bifunctor{Pair}(Bimap f g x = Pair (f (First x)) (g (Second x)))
Def Brackets[T : Star]<Writeable T>(x : T) : List Char =
  (y -> Match Second y {False -> First y, True -> Cat (Lift "(") (Cat (First y) (Lift ")"))}) (Write_Brackets x)
Def Convert'[F : Arrow Star Star, T : Star]<Applicative F, Ring T>(x : Int) : F T = Lift (Convert x)
Def Equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {EQ -> True, Default -> False}
Instance Field{Int}(Inverse x = Match x {-1 -> Wrap -1, 1 -> Wrap 1, Default -> Nothing})
Instance Field{Logical}(Inverse x = Match x {False -> Nothing, True -> Wrap True})
Instance Field{Pair T U}<Field T, Field U>(Inverse x = Zip Pair (Inverse (First x)) (Inverse (Second x)))
Def Filter[T : Star, F : Arrow Star Star]<Alternative F, Monad F>(f : Function T Logical, x : F T) : F T =
  Bind x (y -> Match f y {False -> Empty, True -> Lift y})
Instance Finite{Comparison}(All = List (LT,  EQ,  GT))
Instance Finite{Either T U}<Finite T, Finite U>(All = Cat (Fmap Left All) (Fmap Right All))
Instance Finite{Logical}(All = List (False, True))
Instance Finite{Maybe T}<Finite T>(All = Construct_List Nothing (Fmap Wrap All))
Instance Finite{Pair T U}<Finite T, Finite U>(All = Zip Pair All All)
Def Flatten[F : Arrow Star Star, T : Star]<Monad F>(x : F (F T)) : F T = Bind x Id
Instance Functor{Either _}(Fmap = Map_right)
Instance Functor{Function _}(Fmap f g x = f (g x))
Instance Functor{List}(Fmap f x = Match x {Empty_List -> List, Construct_List y z -> Construct_List (f y) (Fmap f z)})
Instance Functor{Maybe}(Fmap f x = Match x {Nothing -> Nothing, Wrap y -> Wrap (f y)})
Instance Functor{Pair _}(Fmap = Map_right)
Instance Functor{Tree}(
  Fmap f x = Match x {Empty_Tree -> Empty_Tree, Construct_Tree y z a -> Construct_Tree (f y) (Fmap f z) (Fmap f a)})
Def Greater[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {GT -> True, Default -> False}
Def Greater_or_equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {LT -> False, Default -> True}
Def Id[T : Star](x : T) : T = x
Def Interleave[T : Star](x : List T, y : List (List T)) : List T =
  Match y {Empty_List -> List, Construct_List z a -> Cat z (Flatten (Fmap (Cat x) a))}
Def Less[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {LT -> True, Default -> False}
Def Less_or_equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {GT -> False, Default -> True}
Def Map_right[T : Star, U : Star, F : Arrow Star (Arrow Star Star), V : Star]<Bifunctor F> :
  Function (Function T U) (Function (F V T) (F V U)) =
    Bimap Id
Def Max[T : Star]<Ord T>(x : T, y : T) : T = Match Compare x y {LT -> y, Default -> x}
Def Min[T : Star]<Ord T>(x : T, y : T) : T = Match Compare x y {LT -> x, Default -> y}
Def Mod'(x : Int, y : Int) : Int = Unsafe (Mod x y)
Instance Monad{Either _}(Bind x f = Match x {Left y -> Left y, Right y -> f y})
Instance Monad{Function _}(Bind f g x = g (f x) x)
Instance Monad{List}(Bind x f = Match x {Empty_List -> List, Construct_List y z -> Cat (f y) (Bind z f)})
Instance Monad{Maybe}(Bind x f = Match x {Nothing -> Nothing, Wrap y -> f y})
Instance Monad'{Either _}(Unsafe x = Match x {Left _ -> Crash, Right y -> y})
Instance Monad'{Maybe}(Unsafe x = Match x {Nothing -> Crash, Wrap y -> y})
Def Multiply'[F : Arrow Star Star, T : Star]<Applicative F, Ring T> : Function (F T) (Function (F T) (F T)) = Zip Multiply
Def Negate'[F : Arrow Star Star, T : Star]<Functor F, Ring T> : Function (F T) (F T) = Fmap Negate
Def Not(x : Logical) : Logical = Match x {False -> True, True -> False}
Def Not_equal[T : Star]<Ord T>(x : T, y : T) : Logical = Match Compare x y {EQ -> False, Default -> True}
Instance Ord{Comparison}(
  Compare x y =
    Match x {
      LT -> Match y {LT -> EQ, Default -> LT},
      EQ -> Match y {LT -> GT, EQ -> EQ, GT -> LT},
      GT -> Match y {GT -> EQ, Default -> GT}})
Instance Ord{Either T U}<Ord T, Ord U>(
  Compare x y =
    Match x {
      Left z -> Match y {Left w -> Compare z w, Right -> LT},
      Right z -> Match y {Left -> GT, Right w -> Compare z w}})
Instance Ord{Function T U}<Finite T, Ord U>(Compare f g = Compare (Fmap f All) (Fmap g All))
Instance Ord{List T}<Ord T>(
  Compare x y =
    Match x {
      Empty_List -> Match y {Empty_List -> EQ, Construct_List _ _ -> LT},
      Construct_List z a -> Match y {Empty_List -> GT, Construct_List b c -> Compare (Pair z a) (Pair b c)}})
Instance Ord{Logical}(
  Compare x y = Match x {False -> Match y {False -> EQ, True -> LT}, True -> Match y {False -> GT, True -> EQ}})
Instance Ord{Maybe T}<Ord T>(
  Compare x y =
    Match x {Nothing -> Match y {Nothing -> EQ, Wrap -> LT}, Wrap z -> Match y {Nothing -> GT, Wrap w -> Compare z w}})
Instance Ord{Pair T U}<Ord T, Ord U>(
  Compare x y = Match Compare (First x) (First y) {LT -> LT, EQ -> Compare (Second x) (Second y), GT -> GT})
Instance Ord{Tree T}<Ord T>(
  Compare x y =
    Match x {
      Empty_Tree -> Match y {Empty_Tree -> EQ, Construct_Tree _ _ _ -> LT},
      Construct_Tree z a b ->
        Match y {Empty_Tree -> GT, Construct_Tree c d e -> Compare (Pair z (Pair a b)) (Pair c (Pair d e))}})
Instance Ring{Logical}(Add = Not_equal, Convert x = Equal (Mod' x 2) 1, Multiply = Min, Negate = Id)
Instance Ring{Pair T U}<Ring T, Ring U>(
  Add x y = Pair (Add (First x) (First y)) (Add (Second x) (Second y)),
  Convert x = Pair (Convert x) (Convert x),
  Multiply x y = Pair (Multiply (First x) (First y)) (Multiply (Second x) (Second y)),
  Negate x = Pair (Negate (First x)) (Negate (Second x)))
Def Write[T : Star]<Writeable T>(x : T) : List Char = First (Write_Brackets x)
Def Write'(x : List Char, y : List (List Char)) : List Char = Interleave (Lift " ") (Construct_List x y)
Instance Writeable{Char}(
  Write_Brackets c = Pair (Construct_List """ (Cat (Match c {"\n" -> List ("\", "n"), Default -> Lift c}) (Lift """))) False)
Instance Writeable{Comparison}(
  Write_Brackets x = Pair (Match x {LT -> List ("L", "T"), EQ -> List ("E", "Q"), GT -> List ("G", "T")}) False)
Instance Writeable{Either T U}<Writeable T, Writeable U>(
  Write_Brackets x =
    Pair
      (Match x {
        Left y -> Cat (List ("L", "e", "f", "t")) (Brackets y),
        Right y -> Cat (List ("R", "i", "g", "h", "t")) (Brackets y)})
      True)
Instance Writeable{List T}<Writeable T>(
  Write_Brackets x =
    Match x {
      Empty_List -> Pair (List ("L", "i", "s", "t")) False,
      Construct_List y z ->
        Pair
          (Cat (List ("L", "i", "s", "t", " ", "(")) (Cat (Interleave (List (",", " ")) (Fmap Write x)) (Lift ")")))
          True})
Instance Writeable{Logical}(
  Write_Brackets x = Pair (Match x {False -> List ("F", "a", "l", "s", "e"), True -> List ("T", "r", "u", "e")}) False)
Instance Writeable{Maybe T}<Writeable T>(
  Write_Brackets x =
    Match x {
      Nothing -> Pair (List ("N", "o", "t", "h", "i", "n", "g")) False,
      Wrap y -> Pair (Cat (List ("W", "r", "a", "p", " ")) (Brackets y)) True})
Instance Writeable{Pair T U}<Writeable T, Writeable U>(
  Write_Brackets x = Pair (Write' (List ("P", "a", "i", "r")) (List (Brackets (First x), Brackets (Second x)))) True)
Instance Writeable{Tree T}<Writeable T>(
  Write_Brackets x =
    Match x {
      Empty_Tree -> Pair (List ("E", "m", "p", "t", "y", "_", "T", "r", "e", "e")) False,
      Construct_Tree y z a ->
        Pair
          (Write'
            (List ("C", "o", "n", "s", "t", "r", "u", "c", "t", "_", "T", "r", "e", "e"))
            (List (Brackets y, Brackets z, Brackets a)))
          True})
Def Zip[F : Arrow Star Star, T : Star, U : Star, V : Star]<Applicative F>(f : Function T (Function U V), x : F T) :
  Function (F U) (F V) =
    Apply (Fmap f x)
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````